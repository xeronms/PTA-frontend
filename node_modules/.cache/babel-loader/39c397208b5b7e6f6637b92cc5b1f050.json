{"ast":null,"code":"import _objectSpread from \"C:/Users/ESG-dell/Documents/Dev/Hachathon-miasta/PTA-frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _createForOfIteratorHelper from \"C:/Users/ESG-dell/Documents/Dev/Hachathon-miasta/PTA-frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport { earcut } from '@math.gl/polygon';\nexport function featuresToBinary(features, firstPassData) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return fillArrays(features, firstPassData, {\n    numericPropKeys: options.numericPropKeys || extractNumericPropKeys(features),\n    PositionDataType: options.PositionDataType || Float32Array\n  });\n}\nexport var TEST_EXPORTS = {\n  extractNumericPropKeys: extractNumericPropKeys,\n  fillArrays: fillArrays\n};\n\nfunction extractNumericPropKeys(features) {\n  var numericPropKeys = {};\n\n  var _iterator = _createForOfIteratorHelper(features),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var feature = _step.value;\n\n      if (feature.properties) {\n        for (var key in feature.properties) {\n          var numericSoFar = numericPropKeys[key];\n\n          if (numericSoFar || numericSoFar === undefined) {\n            var val = feature.properties[key];\n            numericPropKeys[key] = isNumeric(val);\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return Object.keys(numericPropKeys).filter(function (k) {\n    return numericPropKeys[k];\n  });\n}\n\nfunction fillArrays(features) {\n  var firstPassData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var pointPositionsCount = firstPassData.pointPositionsCount,\n      pointFeaturesCount = firstPassData.pointFeaturesCount,\n      linePositionsCount = firstPassData.linePositionsCount,\n      linePathsCount = firstPassData.linePathsCount,\n      lineFeaturesCount = firstPassData.lineFeaturesCount,\n      polygonPositionsCount = firstPassData.polygonPositionsCount,\n      polygonObjectsCount = firstPassData.polygonObjectsCount,\n      polygonRingsCount = firstPassData.polygonRingsCount,\n      polygonFeaturesCount = firstPassData.polygonFeaturesCount;\n  var numericPropKeys = options.numericPropKeys,\n      _options$PositionData = options.PositionDataType,\n      PositionDataType = _options$PositionData === void 0 ? Float32Array : _options$PositionData;\n  var hasGlobalId = features[0] && 'id' in features[0];\n  var coordLength = 2;\n  var GlobalFeatureIdsDataType = features.length > 65535 ? Uint32Array : Uint16Array;\n  var points = {\n    positions: new PositionDataType(pointPositionsCount * coordLength),\n    globalFeatureIds: new GlobalFeatureIdsDataType(pointPositionsCount),\n    featureIds: pointFeaturesCount > 65535 ? new Uint32Array(pointPositionsCount) : new Uint16Array(pointPositionsCount),\n    numericProps: {},\n    properties: [],\n    fields: []\n  };\n  var lines = {\n    pathIndices: linePositionsCount > 65535 ? new Uint32Array(linePathsCount + 1) : new Uint16Array(linePathsCount + 1),\n    positions: new PositionDataType(linePositionsCount * coordLength),\n    globalFeatureIds: new GlobalFeatureIdsDataType(linePositionsCount),\n    featureIds: lineFeaturesCount > 65535 ? new Uint32Array(linePositionsCount) : new Uint16Array(linePositionsCount),\n    numericProps: {},\n    properties: [],\n    fields: []\n  };\n  var polygons = {\n    polygonIndices: polygonPositionsCount > 65535 ? new Uint32Array(polygonObjectsCount + 1) : new Uint16Array(polygonObjectsCount + 1),\n    primitivePolygonIndices: polygonPositionsCount > 65535 ? new Uint32Array(polygonRingsCount + 1) : new Uint16Array(polygonRingsCount + 1),\n    positions: new PositionDataType(polygonPositionsCount * coordLength),\n    triangles: [],\n    globalFeatureIds: new GlobalFeatureIdsDataType(polygonPositionsCount),\n    featureIds: polygonFeaturesCount > 65535 ? new Uint32Array(polygonPositionsCount) : new Uint16Array(polygonPositionsCount),\n    numericProps: {},\n    properties: [],\n    fields: []\n  };\n\n  for (var _i = 0, _arr = [points, lines, polygons]; _i < _arr.length; _i++) {\n    var object = _arr[_i];\n\n    var _iterator2 = _createForOfIteratorHelper(numericPropKeys),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var propName = _step2.value;\n        object.numericProps[propName] = new Float32Array(object.positions.length / coordLength);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n\n  lines.pathIndices[linePathsCount] = linePositionsCount;\n  polygons.polygonIndices[polygonObjectsCount] = polygonPositionsCount;\n  polygons.primitivePolygonIndices[polygonRingsCount] = polygonPositionsCount;\n  var indexMap = {\n    pointPosition: 0,\n    pointFeature: 0,\n    linePosition: 0,\n    linePath: 0,\n    lineFeature: 0,\n    polygonPosition: 0,\n    polygonObject: 0,\n    polygonRing: 0,\n    polygonFeature: 0,\n    feature: 0\n  };\n\n  var _iterator3 = _createForOfIteratorHelper(features),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var feature = _step3.value;\n      var geometry = feature.geometry;\n      var properties = feature.properties || {};\n\n      switch (geometry.type) {\n        case 'Point':\n        case 'MultiPoint':\n          handlePoint(geometry, points, indexMap, coordLength, properties);\n          points.properties.push(keepStringProperties(properties, numericPropKeys));\n\n          if (hasGlobalId) {\n            points.fields.push({\n              id: feature.id\n            });\n          }\n\n          indexMap.pointFeature++;\n          break;\n\n        case 'LineString':\n        case 'MultiLineString':\n          handleLineString(geometry, lines, indexMap, coordLength, properties);\n          lines.properties.push(keepStringProperties(properties, numericPropKeys));\n\n          if (hasGlobalId) {\n            lines.fields.push({\n              id: feature.id\n            });\n          }\n\n          indexMap.lineFeature++;\n          break;\n\n        case 'Polygon':\n        case 'MultiPolygon':\n          handlePolygon(geometry, polygons, indexMap, coordLength, properties);\n          polygons.properties.push(keepStringProperties(properties, numericPropKeys));\n\n          if (hasGlobalId) {\n            polygons.fields.push({\n              id: feature.id\n            });\n          }\n\n          indexMap.polygonFeature++;\n          break;\n\n        default:\n          throw new Error('Invalid geometry type');\n      }\n\n      indexMap.feature++;\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  return makeAccessorObjects(points, lines, polygons, coordLength);\n}\n\nfunction handlePoint(geometry, points, indexMap, coordLength, properties) {\n  points.positions.set(geometry.data, indexMap.pointPosition * coordLength);\n  var nPositions = geometry.data.length / coordLength;\n  fillNumericProperties(points, properties, indexMap.pointPosition, nPositions);\n  points.globalFeatureIds.fill(indexMap.feature, indexMap.pointPosition, indexMap.pointPosition + nPositions);\n  points.featureIds.fill(indexMap.pointFeature, indexMap.pointPosition, indexMap.pointPosition + nPositions);\n  indexMap.pointPosition += nPositions;\n}\n\nfunction handleLineString(geometry, lines, indexMap, coordLength, properties) {\n  lines.positions.set(geometry.data, indexMap.linePosition * coordLength);\n  var nPositions = geometry.data.length / coordLength;\n  fillNumericProperties(lines, properties, indexMap.linePosition, nPositions);\n  lines.globalFeatureIds.fill(indexMap.feature, indexMap.linePosition, indexMap.linePosition + nPositions);\n  lines.featureIds.fill(indexMap.lineFeature, indexMap.linePosition, indexMap.linePosition + nPositions);\n\n  for (var i = 0, il = geometry.lines.length; i < il; ++i) {\n    var start = geometry.lines[i];\n    var end = i === il - 1 ? geometry.data.length : geometry.lines[i + 1];\n    lines.pathIndices[indexMap.linePath++] = indexMap.linePosition;\n    indexMap.linePosition += (end - start) / coordLength;\n  }\n}\n\nfunction handlePolygon(geometry, polygons, indexMap, coordLength, properties) {\n  polygons.positions.set(geometry.data, indexMap.polygonPosition * coordLength);\n  var nPositions = geometry.data.length / coordLength;\n  fillNumericProperties(polygons, properties, indexMap.polygonPosition, nPositions);\n  polygons.globalFeatureIds.fill(indexMap.feature, indexMap.polygonPosition, indexMap.polygonPosition + nPositions);\n  polygons.featureIds.fill(indexMap.polygonFeature, indexMap.polygonPosition, indexMap.polygonPosition + nPositions);\n\n  for (var l = 0, ll = geometry.lines.length; l < ll; ++l) {\n    var startPosition = indexMap.polygonPosition;\n    polygons.polygonIndices[indexMap.polygonObject++] = startPosition;\n    var areas = geometry.areas[l];\n    var lines = geometry.lines[l];\n    var nextLines = geometry.lines[l + 1];\n\n    for (var i = 0, il = lines.length; i < il; ++i) {\n      var start = lines[i];\n      var end = i === il - 1 ? nextLines === undefined ? geometry.data.length : nextLines[0] : lines[i + 1];\n      polygons.primitivePolygonIndices[indexMap.polygonRing++] = indexMap.polygonPosition;\n      indexMap.polygonPosition += (end - start) / coordLength;\n    }\n\n    var endPosition = indexMap.polygonPosition;\n    triangulatePolygon(polygons, areas, lines, {\n      startPosition: startPosition,\n      endPosition: endPosition,\n      coordLength: coordLength\n    });\n  }\n}\n\nfunction triangulatePolygon(polygons, areas, lines, _ref) {\n  var startPosition = _ref.startPosition,\n      endPosition = _ref.endPosition,\n      coordLength = _ref.coordLength;\n  var start = startPosition * coordLength;\n  var end = endPosition * coordLength;\n  var polygonPositions = polygons.positions.subarray(start, end);\n  var offset = lines[0];\n  var holes = lines.slice(1).map(function (n) {\n    return (n - offset) / coordLength;\n  });\n  var indices = earcut(polygonPositions, holes, coordLength, areas);\n\n  for (var t = 0, tl = indices.length; t < tl; ++t) {\n    polygons.triangles.push(startPosition + indices[t]);\n  }\n}\n\nfunction makeAccessorObjects(points, lines, polygons, coordLength) {\n  var returnObj = {\n    points: _objectSpread(_objectSpread({}, points), {}, {\n      positions: {\n        value: points.positions,\n        size: coordLength\n      },\n      globalFeatureIds: {\n        value: points.globalFeatureIds,\n        size: 1\n      },\n      featureIds: {\n        value: points.featureIds,\n        size: 1\n      }\n    }),\n    lines: _objectSpread(_objectSpread({}, lines), {}, {\n      pathIndices: {\n        value: lines.pathIndices,\n        size: 1\n      },\n      positions: {\n        value: lines.positions,\n        size: coordLength\n      },\n      globalFeatureIds: {\n        value: lines.globalFeatureIds,\n        size: 1\n      },\n      featureIds: {\n        value: lines.featureIds,\n        size: 1\n      }\n    }),\n    polygons: _objectSpread(_objectSpread({}, polygons), {}, {\n      polygonIndices: {\n        value: polygons.polygonIndices,\n        size: 1\n      },\n      primitivePolygonIndices: {\n        value: polygons.primitivePolygonIndices,\n        size: 1\n      },\n      positions: {\n        value: polygons.positions,\n        size: coordLength\n      },\n      triangles: {\n        value: new Uint32Array(polygons.triangles),\n        size: 1\n      },\n      globalFeatureIds: {\n        value: polygons.globalFeatureIds,\n        size: 1\n      },\n      featureIds: {\n        value: polygons.featureIds,\n        size: 1\n      }\n    })\n  };\n\n  for (var geomType in returnObj) {\n    for (var numericProp in returnObj[geomType].numericProps) {\n      returnObj[geomType].numericProps[numericProp] = {\n        value: returnObj[geomType].numericProps[numericProp],\n        size: 1\n      };\n    }\n  }\n\n  return returnObj;\n}\n\nfunction fillNumericProperties(object, properties, index, length) {\n  for (var numericPropName in object.numericProps) {\n    if (numericPropName in properties) {\n      object.numericProps[numericPropName].fill(properties[numericPropName], index, index + length);\n    }\n  }\n}\n\nfunction keepStringProperties(properties, numericKeys) {\n  var props = {};\n\n  for (var key in properties) {\n    if (!numericKeys.includes(key)) {\n      props[key] = properties[key];\n    }\n  }\n\n  return props;\n}\n\nfunction isNumeric(x) {\n  return Number.isFinite(x);\n}","map":{"version":3,"sources":["../../../../src/lib/binary-vector-tile/features-to-binary.js"],"names":["options","fillArrays","numericPropKeys","extractNumericPropKeys","PositionDataType","Float32Array","TEST_EXPORTS","feature","numericSoFar","val","isNumeric","Object","k","firstPassData","polygonFeaturesCount","hasGlobalId","features","coordLength","GlobalFeatureIdsDataType","points","positions","pointPositionsCount","globalFeatureIds","featureIds","pointFeaturesCount","numericProps","properties","fields","lines","pathIndices","linePositionsCount","linePathsCount","lineFeaturesCount","polygons","polygonIndices","polygonPositionsCount","polygonObjectsCount","primitivePolygonIndices","polygonRingsCount","triangles","object","indexMap","pointPosition","pointFeature","linePosition","linePath","lineFeature","polygonPosition","polygonObject","polygonRing","polygonFeature","geometry","handlePoint","keepStringProperties","id","handleLineString","handlePolygon","makeAccessorObjects","nPositions","fillNumericProperties","i","il","start","end","l","ll","startPosition","areas","nextLines","endPosition","triangulatePolygon","polygonPositions","offset","holes","n","indices","earcut","t","tl","returnObj","value","size","numericPropName","index","props","numericKeys","Number"],"mappings":";;AACA,SAAA,MAAA,QAAA,kBAAA;AAUA,OAAO,SAAA,gBAAA,CAAA,QAAA,EAAA,aAAA,EAAiE;AAAA,MAAdA,OAAc,uEAAjE,EAAiE;AACtE,SAAOC,UAAU,CAAA,QAAA,EAAA,aAAA,EAA0B;AACzCC,IAAAA,eAAe,EAAEF,OAAO,CAAPA,eAAAA,IAA2BG,sBAAsB,CADzB,QACyB,CADzB;AAEzCC,IAAAA,gBAAgB,EAAEJ,OAAO,CAAPA,gBAAAA,IAA4BK;AAFL,GAA1B,CAAjB;AAID;AAED,OAAO,IAAMC,YAAY,GAAG;AAC1BH,EAAAA,sBAD0B,EAC1BA,sBAD0B;AAE1BF,EAAAA,UAAAA,EAAAA;AAF0B,CAArB;;AAOP,SAAA,sBAAA,CAAA,QAAA,EAA0C;AACxC,MAAMC,eAAe,GAArB,EAAA;;AADwC,6CAExC,QAFwC;AAAA;;AAAA;AAExC,wDAAgC;AAAA,UAAhC,OAAgC;;AAC9B,UAAIK,OAAO,CAAX,UAAA,EAAwB;AACtB,aAAK,IAAL,GAAA,IAAkBA,OAAO,CAAzB,UAAA,EAAsC;AAIpC,cAAMC,YAAY,GAAGN,eAAe,CAApC,GAAoC,CAApC;;AAEA,cAAIM,YAAY,IAAIA,YAAY,KAAhC,SAAA,EAAgD;AAC9C,gBAAMC,GAAG,GAAGF,OAAO,CAAPA,UAAAA,CAAZ,GAAYA,CAAZ;AACAL,YAAAA,eAAe,CAAfA,GAAe,CAAfA,GAAuBQ,SAAS,CAAhCR,GAAgC,CAAhCA;AACD;AACF;AACF;AACF;AAhBuC;AAAA;AAAA;AAAA;AAAA;;AAkBxC,SAAOS,MAAM,CAANA,IAAAA,CAAAA,eAAAA,EAAAA,MAAAA,CAAqCC,UAAAA,CAAD;AAAA,WAAOV,eAAe,CAAjE,CAAiE,CAAtB;AAAA,GAApCS,CAAP;AACD;;AAID,SAAA,UAAA,CAAA,QAAA,EAAgE;AAAA,MAAlCE,aAAkC,uEAAhE,EAAgE;AAAA,MAAdb,OAAc,uEAAhE,EAAgE;AAC9D,MAAM,mBAAN,GAAA,aAAA,CAAM,mBAAN;AAAA,MAAM,kBAAN,GAAA,aAAA,CAAM,kBAAN;AAAA,MAAM,kBAAN,GAAA,aAAA,CAAM,kBAAN;AAAA,MAAM,cAAN,GAAA,aAAA,CAAM,cAAN;AAAA,MAAM,iBAAN,GAAA,aAAA,CAAM,iBAAN;AAAA,MAAM,qBAAN,GAAA,aAAA,CAAM,qBAAN;AAAA,MAAM,mBAAN,GAAA,aAAA,CAAM,mBAAN;AAAA,MAAM,iBAAN,GAAA,aAAA,CAAM,iBAAN;AAAA,MASEc,oBATF,GAAA,aAAA,CASEA,oBATF;AAWA,MAAM,eAAN,GAAA,OAAA,CAAM,eAAN;AAAA,8BAAA,OAAA,CAAwBV,gBAAxB;AAAA,MAAwBA,gBAAxB,sCAA2CC,YAA3C;AACA,MAAMU,WAAW,GAAGC,QAAQ,CAARA,CAAQ,CAARA,IAAe,QAAQA,QAAQ,CAAnD,CAAmD,CAAnD;AACA,MAAMC,WAAW,GAAjB,CAAA;AACA,MAAMC,wBAAwB,GAAGF,QAAQ,CAARA,MAAAA,GAAAA,KAAAA,GAAAA,WAAAA,GAAjC,WAAA;AACA,MAAMG,MAAM,GAAG;AACbC,IAAAA,SAAS,EAAE,IAAA,gBAAA,CAAqBC,mBAAmB,GADtC,WACF,CADE;AAEbC,IAAAA,gBAAgB,EAAE,IAAA,wBAAA,CAFL,mBAEK,CAFL;AAGbC,IAAAA,UAAU,EACRC,kBAAkB,GAAlBA,KAAAA,GACI,IAAA,WAAA,CADJA,mBACI,CADJA,GAEI,IAAA,WAAA,CANO,mBAMP,CANO;AAObC,IAAAA,YAAY,EAPC,EAAA;AAQbC,IAAAA,UAAU,EARG,EAAA;AASbC,IAAAA,MAAM,EAAE;AATK,GAAf;AAWA,MAAMC,KAAK,GAAG;AACZC,IAAAA,WAAW,EACTC,kBAAkB,GAAlBA,KAAAA,GACI,IAAA,WAAA,CAAgBC,cAAc,GADlCD,CACI,CADJA,GAEI,IAAA,WAAA,CAAgBC,cAAc,GAJxB,CAIN,CAJM;AAKZX,IAAAA,SAAS,EAAE,IAAA,gBAAA,CAAqBU,kBAAkB,GALtC,WAKD,CALC;AAMZR,IAAAA,gBAAgB,EAAE,IAAA,wBAAA,CANN,kBAMM,CANN;AAOZC,IAAAA,UAAU,EACRS,iBAAiB,GAAjBA,KAAAA,GACI,IAAA,WAAA,CADJA,kBACI,CADJA,GAEI,IAAA,WAAA,CAVM,kBAUN,CAVM;AAWZP,IAAAA,YAAY,EAXA,EAAA;AAYZC,IAAAA,UAAU,EAZE,EAAA;AAaZC,IAAAA,MAAM,EAAE;AAbI,GAAd;AAeA,MAAMM,QAAQ,GAAG;AACfC,IAAAA,cAAc,EACZC,qBAAqB,GAArBA,KAAAA,GACI,IAAA,WAAA,CAAgBC,mBAAmB,GADvCD,CACI,CADJA,GAEI,IAAA,WAAA,CAAgBC,mBAAmB,GAJ1B,CAIT,CAJS;AAKfC,IAAAA,uBAAuB,EACrBF,qBAAqB,GAArBA,KAAAA,GACI,IAAA,WAAA,CAAgBG,iBAAiB,GADrCH,CACI,CADJA,GAEI,IAAA,WAAA,CAAgBG,iBAAiB,GARxB,CAQT,CARS;AASflB,IAAAA,SAAS,EAAE,IAAA,gBAAA,CAAqBe,qBAAqB,GATtC,WASJ,CATI;AAUfI,IAAAA,SAAS,EAVM,EAAA;AAWfjB,IAAAA,gBAAgB,EAAE,IAAA,wBAAA,CAXH,qBAWG,CAXH;AAYfC,IAAAA,UAAU,EACRT,oBAAoB,GAApBA,KAAAA,GACI,IAAA,WAAA,CADJA,qBACI,CADJA,GAEI,IAAA,WAAA,CAfS,qBAeT,CAfS;AAgBfW,IAAAA,YAAY,EAhBG,EAAA;AAiBfC,IAAAA,UAAU,EAjBK,EAAA;AAkBfC,IAAAA,MAAM,EAAE;AAlBO,GAAjB;;AAsBA,0BAAqB,CAAA,MAAA,EAAA,KAAA,EAArB,QAAqB,CAArB,0BAAgD;AAA3C,QAAMa,MAAX,WAAK;;AAA2C,gDAC9C,eAD8C;AAAA;;AAAA;AAC9C,6DAAwC;AAAA,YAAxC,QAAwC;AAGtCA,QAAAA,MAAM,CAANA,YAAAA,CAAAA,QAAAA,IAAgC,IAAA,YAAA,CAAiBA,MAAM,CAANA,SAAAA,CAAAA,MAAAA,GAAjDA,WAAgC,CAAhCA;AACD;AAL6C;AAAA;AAAA;AAAA;AAAA;AAM/C;;AAGDZ,EAAAA,KAAK,CAALA,WAAAA,CAAAA,cAAAA,IAAAA,kBAAAA;AACAK,EAAAA,QAAQ,CAARA,cAAAA,CAAAA,mBAAAA,IAAAA,qBAAAA;AACAA,EAAAA,QAAQ,CAARA,uBAAAA,CAAAA,iBAAAA,IAAAA,qBAAAA;AAEA,MAAMQ,QAAQ,GAAG;AACfC,IAAAA,aAAa,EADE,CAAA;AAEfC,IAAAA,YAAY,EAFG,CAAA;AAGfC,IAAAA,YAAY,EAHG,CAAA;AAIfC,IAAAA,QAAQ,EAJO,CAAA;AAKfC,IAAAA,WAAW,EALI,CAAA;AAMfC,IAAAA,eAAe,EANA,CAAA;AAOfC,IAAAA,aAAa,EAPE,CAAA;AAQfC,IAAAA,WAAW,EARI,CAAA;AASfC,IAAAA,cAAc,EATC,CAAA;AAUf3C,IAAAA,OAAO,EAAE;AAVM,GAAjB;;AA7E8D,8CA0F9D,QA1F8D;AAAA;;AAAA;AA0F9D,2DAAgC;AAAA,UAAhC,OAAgC;AAC9B,UAAM4C,QAAQ,GAAG5C,OAAO,CAAxB,QAAA;AACA,UAAMmB,UAAU,GAAGnB,OAAO,CAAPA,UAAAA,IAAnB,EAAA;;AAEA,cAAQ4C,QAAQ,CAAhB,IAAA;AACE,aAAA,OAAA;AACA,aAAA,YAAA;AACEC,UAAAA,WAAW,CAAA,QAAA,EAAA,MAAA,EAAA,QAAA,EAAA,WAAA,EAAXA,UAAW,CAAXA;AACAjC,UAAAA,MAAM,CAANA,UAAAA,CAAAA,IAAAA,CAAuBkC,oBAAoB,CAAA,UAAA,EAA3ClC,eAA2C,CAA3CA;;AACA,cAAA,WAAA,EAAiB;AACfA,YAAAA,MAAM,CAANA,MAAAA,CAAAA,IAAAA,CAAmB;AAACmC,cAAAA,EAAE,EAAE/C,OAAO,CAAC+C;AAAb,aAAnBnC;AACD;;AACDsB,UAAAA,QAAQ,CAARA,YAAAA;AACA;;AACF,aAAA,YAAA;AACA,aAAA,iBAAA;AACEc,UAAAA,gBAAgB,CAAA,QAAA,EAAA,KAAA,EAAA,QAAA,EAAA,WAAA,EAAhBA,UAAgB,CAAhBA;AACA3B,UAAAA,KAAK,CAALA,UAAAA,CAAAA,IAAAA,CAAsByB,oBAAoB,CAAA,UAAA,EAA1CzB,eAA0C,CAA1CA;;AACA,cAAA,WAAA,EAAiB;AACfA,YAAAA,KAAK,CAALA,MAAAA,CAAAA,IAAAA,CAAkB;AAAC0B,cAAAA,EAAE,EAAE/C,OAAO,CAAC+C;AAAb,aAAlB1B;AACD;;AACDa,UAAAA,QAAQ,CAARA,WAAAA;AACA;;AACF,aAAA,SAAA;AACA,aAAA,cAAA;AACEe,UAAAA,aAAa,CAAA,QAAA,EAAA,QAAA,EAAA,QAAA,EAAA,WAAA,EAAbA,UAAa,CAAbA;AACAvB,UAAAA,QAAQ,CAARA,UAAAA,CAAAA,IAAAA,CAAyBoB,oBAAoB,CAAA,UAAA,EAA7CpB,eAA6C,CAA7CA;;AACA,cAAA,WAAA,EAAiB;AACfA,YAAAA,QAAQ,CAARA,MAAAA,CAAAA,IAAAA,CAAqB;AAACqB,cAAAA,EAAE,EAAE/C,OAAO,CAAC+C;AAAb,aAArBrB;AACD;;AACDQ,UAAAA,QAAQ,CAARA,cAAAA;AACA;;AACF;AACE,gBAAM,IAAA,KAAA,CAAN,uBAAM,CAAN;AA7BJ;;AAgCAA,MAAAA,QAAQ,CAARA,OAAAA;AACD;AA/H6D;AAAA;AAAA;AAAA;AAAA;;AAkI9D,SAAOgB,mBAAmB,CAAA,MAAA,EAAA,KAAA,EAAA,QAAA,EAA1B,WAA0B,CAA1B;AACD;;AAGD,SAAA,WAAA,CAAA,QAAA,EAAA,MAAA,EAAA,QAAA,EAAA,WAAA,EAAA,UAAA,EAA0E;AACxEtC,EAAAA,MAAM,CAANA,SAAAA,CAAAA,GAAAA,CAAqBgC,QAAQ,CAA7BhC,IAAAA,EAAoCsB,QAAQ,CAARA,aAAAA,GAApCtB,WAAAA;AAEA,MAAMuC,UAAU,GAAGP,QAAQ,CAARA,IAAAA,CAAAA,MAAAA,GAAnB,WAAA;AACAQ,EAAAA,qBAAqB,CAAA,MAAA,EAAA,UAAA,EAAqBlB,QAAQ,CAA7B,aAAA,EAArBkB,UAAqB,CAArBA;AACAxC,EAAAA,MAAM,CAANA,gBAAAA,CAAAA,IAAAA,CACEsB,QAAQ,CADVtB,OAAAA,EAEEsB,QAAQ,CAFVtB,aAAAA,EAGEsB,QAAQ,CAARA,aAAAA,GAHFtB,UAAAA;AAKAA,EAAAA,MAAM,CAANA,UAAAA,CAAAA,IAAAA,CACEsB,QAAQ,CADVtB,YAAAA,EAEEsB,QAAQ,CAFVtB,aAAAA,EAGEsB,QAAQ,CAARA,aAAAA,GAHFtB,UAAAA;AAMAsB,EAAAA,QAAQ,CAARA,aAAAA,IAAAA,UAAAA;AACD;;AAGD,SAAA,gBAAA,CAAA,QAAA,EAAA,KAAA,EAAA,QAAA,EAAA,WAAA,EAAA,UAAA,EAA8E;AAC5Eb,EAAAA,KAAK,CAALA,SAAAA,CAAAA,GAAAA,CAAoBuB,QAAQ,CAA5BvB,IAAAA,EAAmCa,QAAQ,CAARA,YAAAA,GAAnCb,WAAAA;AAEA,MAAM8B,UAAU,GAAGP,QAAQ,CAARA,IAAAA,CAAAA,MAAAA,GAAnB,WAAA;AACAQ,EAAAA,qBAAqB,CAAA,KAAA,EAAA,UAAA,EAAoBlB,QAAQ,CAA5B,YAAA,EAArBkB,UAAqB,CAArBA;AAEA/B,EAAAA,KAAK,CAALA,gBAAAA,CAAAA,IAAAA,CACEa,QAAQ,CADVb,OAAAA,EAEEa,QAAQ,CAFVb,YAAAA,EAGEa,QAAQ,CAARA,YAAAA,GAHFb,UAAAA;AAKAA,EAAAA,KAAK,CAALA,UAAAA,CAAAA,IAAAA,CACEa,QAAQ,CADVb,WAAAA,EAEEa,QAAQ,CAFVb,YAAAA,EAGEa,QAAQ,CAARA,YAAAA,GAHFb,UAAAA;;AAMA,OAAK,IAAIgC,CAAC,GAAL,CAAA,EAAWC,EAAE,GAAGV,QAAQ,CAARA,KAAAA,CAArB,MAAA,EAA4CS,CAAC,GAA7C,EAAA,EAAoD,EAApD,CAAA,EAAyD;AAGvD,QAAME,KAAK,GAAGX,QAAQ,CAARA,KAAAA,CAAd,CAAcA,CAAd;AACA,QAAMY,GAAG,GACPH,CAAC,KAAKC,EAAE,GAARD,CAAAA,GACIT,QAAQ,CAARA,IAAAA,CADJS,MAAAA,GAEIT,QAAQ,CAARA,KAAAA,CAAeS,CAAC,GAHtB,CAGMT,CAHN;AAKAvB,IAAAA,KAAK,CAALA,WAAAA,CAAkBa,QAAQ,CAA1Bb,QAAkBa,EAAlBb,IAAyCa,QAAQ,CAAjDb,YAAAA;AACAa,IAAAA,QAAQ,CAARA,YAAAA,IAAyB,CAACsB,GAAG,GAAJ,KAAA,IAAzBtB,WAAAA;AACD;AACF;;AAGD,SAAA,aAAA,CAAA,QAAA,EAAA,QAAA,EAAA,QAAA,EAAA,WAAA,EAAA,UAAA,EAA8E;AAC5ER,EAAAA,QAAQ,CAARA,SAAAA,CAAAA,GAAAA,CAAuBkB,QAAQ,CAA/BlB,IAAAA,EAAsCQ,QAAQ,CAARA,eAAAA,GAAtCR,WAAAA;AAEA,MAAMyB,UAAU,GAAGP,QAAQ,CAARA,IAAAA,CAAAA,MAAAA,GAAnB,WAAA;AACAQ,EAAAA,qBAAqB,CAAA,QAAA,EAAA,UAAA,EAAuBlB,QAAQ,CAA/B,eAAA,EAArBkB,UAAqB,CAArBA;AACA1B,EAAAA,QAAQ,CAARA,gBAAAA,CAAAA,IAAAA,CACEQ,QAAQ,CADVR,OAAAA,EAEEQ,QAAQ,CAFVR,eAAAA,EAGEQ,QAAQ,CAARA,eAAAA,GAHFR,UAAAA;AAKAA,EAAAA,QAAQ,CAARA,UAAAA,CAAAA,IAAAA,CACEQ,QAAQ,CADVR,cAAAA,EAEEQ,QAAQ,CAFVR,eAAAA,EAGEQ,QAAQ,CAARA,eAAAA,GAHFR,UAAAA;;AAOA,OAAK,IAAI+B,CAAC,GAAL,CAAA,EAAWC,EAAE,GAAGd,QAAQ,CAARA,KAAAA,CAArB,MAAA,EAA4Ca,CAAC,GAA7C,EAAA,EAAoD,EAApD,CAAA,EAAyD;AACvD,QAAME,aAAa,GAAGzB,QAAQ,CAA9B,eAAA;AACAR,IAAAA,QAAQ,CAARA,cAAAA,CAAwBQ,QAAQ,CAAhCR,aAAwBQ,EAAxBR,IAAAA,aAAAA;AAEA,QAAMkC,KAAK,GAAGhB,QAAQ,CAARA,KAAAA,CAAd,CAAcA,CAAd;AACA,QAAMvB,KAAK,GAAGuB,QAAQ,CAARA,KAAAA,CAAd,CAAcA,CAAd;AACA,QAAMiB,SAAS,GAAGjB,QAAQ,CAARA,KAAAA,CAAea,CAAC,GAAlC,CAAkBb,CAAlB;;AAEA,SAAK,IAAIS,CAAC,GAAL,CAAA,EAAWC,EAAE,GAAGjC,KAAK,CAA1B,MAAA,EAAmCgC,CAAC,GAApC,EAAA,EAA2C,EAA3C,CAAA,EAAgD;AAC9C,UAAME,KAAK,GAAGlC,KAAK,CAAnB,CAAmB,CAAnB;AACA,UAAMmC,GAAG,GACPH,CAAC,KAAKC,EAAE,GAARD,CAAAA,GAEIQ,SAAS,KAATA,SAAAA,GACEjB,QAAQ,CAARA,IAAAA,CADFiB,MAAAA,GAEEA,SAAS,CAJfR,CAIe,CAJfA,GAKIhC,KAAK,CAACgC,CAAC,GANb,CAMW,CANX;AAQA3B,MAAAA,QAAQ,CAARA,uBAAAA,CAAiCQ,QAAQ,CAAzCR,WAAiCQ,EAAjCR,IAA2DQ,QAAQ,CAAnER,eAAAA;AACAQ,MAAAA,QAAQ,CAARA,eAAAA,IAA4B,CAACsB,GAAG,GAAJ,KAAA,IAA5BtB,WAAAA;AACD;;AAED,QAAM4B,WAAW,GAAG5B,QAAQ,CAA5B,eAAA;AACA6B,IAAAA,kBAAkB,CAAA,QAAA,EAAA,KAAA,EAAA,KAAA,EAAyB;AAACJ,MAAAA,aAAD,EAACA,aAAD;AAAgBG,MAAAA,WAAhB,EAAgBA,WAAhB;AAA6BpD,MAAAA,WAAAA,EAAAA;AAA7B,KAAzB,CAAlBqD;AACD;AACF;;AAKD,SAAA,kBAAA,CAAA,QAAA,EAAA,KAAA,EAAA,KAAA,QAA+F;AAAA,MAA3C,aAA2C,QAA3C,aAA2C;AAAA,MAA3C,WAA2C,QAA3C,WAA2C;AAAA,MAAdrD,WAAc,QAAdA,WAAc;AAC7F,MAAM6C,KAAK,GAAGI,aAAa,GAA3B,WAAA;AACA,MAAMH,GAAG,GAAGM,WAAW,GAAvB,WAAA;AAGA,MAAME,gBAAgB,GAAGtC,QAAQ,CAARA,SAAAA,CAAAA,QAAAA,CAAAA,KAAAA,EAAzB,GAAyBA,CAAzB;AAGA,MAAMuC,MAAM,GAAG5C,KAAK,CAApB,CAAoB,CAApB;AACA,MAAM6C,KAAK,GAAG7C,KAAK,CAALA,KAAAA,CAAAA,CAAAA,EAAAA,GAAAA,CAAoB8C,UAAAA,CAAD;AAAA,WAAO,CAACA,CAAC,GAAF,MAAA,IAAxC,WAAiC;AAAA,GAAnB9C,CAAd;AAGA,MAAM+C,OAAO,GAAGC,MAAM,CAAA,gBAAA,EAAA,KAAA,EAAA,WAAA,EAAtB,KAAsB,CAAtB;;AAIA,OAAK,IAAIC,CAAC,GAAL,CAAA,EAAWC,EAAE,GAAGH,OAAO,CAA5B,MAAA,EAAqCE,CAAC,GAAtC,EAAA,EAA6C,EAA7C,CAAA,EAAkD;AAChD5C,IAAAA,QAAQ,CAARA,SAAAA,CAAAA,IAAAA,CAAwBiC,aAAa,GAAGS,OAAO,CAA/C1C,CAA+C,CAA/CA;AACD;AACF;;AAGD,SAAA,mBAAA,CAAA,MAAA,EAAA,KAAA,EAAA,QAAA,EAAA,WAAA,EAAmE;AACjE,MAAM8C,SAAS,GAAG;AAChB5D,IAAAA,MAAM,kCAAE,MAAF;AAEJC,MAAAA,SAAS,EAAE;AAAC4D,QAAAA,KAAK,EAAE7D,MAAM,CAAd,SAAA;AAA0B8D,QAAAA,IAAI,EAAEhE;AAAhC,OAFP;AAGJK,MAAAA,gBAAgB,EAAE;AAAC0D,QAAAA,KAAK,EAAE7D,MAAM,CAAd,gBAAA;AAAiC8D,QAAAA,IAAI,EAAE;AAAvC,OAHd;AAIJ1D,MAAAA,UAAU,EAAE;AAACyD,QAAAA,KAAK,EAAE7D,MAAM,CAAd,UAAA;AAA2B8D,QAAAA,IAAI,EAAE;AAAjC;AAJR,MADU;AAOhBrD,IAAAA,KAAK,kCAAE,KAAF;AAEHC,MAAAA,WAAW,EAAE;AAACmD,QAAAA,KAAK,EAAEpD,KAAK,CAAb,WAAA;AAA2BqD,QAAAA,IAAI,EAAE;AAAjC,OAFV;AAGH7D,MAAAA,SAAS,EAAE;AAAC4D,QAAAA,KAAK,EAAEpD,KAAK,CAAb,SAAA;AAAyBqD,QAAAA,IAAI,EAAEhE;AAA/B,OAHR;AAIHK,MAAAA,gBAAgB,EAAE;AAAC0D,QAAAA,KAAK,EAAEpD,KAAK,CAAb,gBAAA;AAAgCqD,QAAAA,IAAI,EAAE;AAAtC,OAJf;AAKH1D,MAAAA,UAAU,EAAE;AAACyD,QAAAA,KAAK,EAAEpD,KAAK,CAAb,UAAA;AAA0BqD,QAAAA,IAAI,EAAE;AAAhC;AALT,MAPW;AAchBhD,IAAAA,QAAQ,kCAAE,QAAF;AAENC,MAAAA,cAAc,EAAE;AAAC8C,QAAAA,KAAK,EAAE/C,QAAQ,CAAhB,cAAA;AAAiCgD,QAAAA,IAAI,EAAE;AAAvC,OAFV;AAGN5C,MAAAA,uBAAuB,EAAE;AAAC2C,QAAAA,KAAK,EAAE/C,QAAQ,CAAhB,uBAAA;AAA0CgD,QAAAA,IAAI,EAAE;AAAhD,OAHnB;AAIN7D,MAAAA,SAAS,EAAE;AAAC4D,QAAAA,KAAK,EAAE/C,QAAQ,CAAhB,SAAA;AAA4BgD,QAAAA,IAAI,EAAEhE;AAAlC,OAJL;AAKNsB,MAAAA,SAAS,EAAE;AAACyC,QAAAA,KAAK,EAAE,IAAA,WAAA,CAAgB/C,QAAQ,CAAhC,SAAQ,CAAR;AAA6CgD,QAAAA,IAAI,EAAE;AAAnD,OALL;AAMN3D,MAAAA,gBAAgB,EAAE;AAAC0D,QAAAA,KAAK,EAAE/C,QAAQ,CAAhB,gBAAA;AAAmCgD,QAAAA,IAAI,EAAE;AAAzC,OANZ;AAON1D,MAAAA,UAAU,EAAE;AAACyD,QAAAA,KAAK,EAAE/C,QAAQ,CAAhB,UAAA;AAA6BgD,QAAAA,IAAI,EAAE;AAAnC;AAPN;AAdQ,GAAlB;;AAyBA,OAAK,IAAL,QAAA,IAAA,SAAA,EAAkC;AAChC,SAAK,IAAL,WAAA,IAA0BF,SAAS,CAATA,QAAS,CAATA,CAA1B,YAAA,EAA4D;AAC1DA,MAAAA,SAAS,CAATA,QAAS,CAATA,CAAAA,YAAAA,CAAAA,WAAAA,IAAgD;AAC9CC,QAAAA,KAAK,EAAED,SAAS,CAATA,QAAS,CAATA,CAAAA,YAAAA,CADuC,WACvCA,CADuC;AAE9CE,QAAAA,IAAI,EAAE;AAFwC,OAAhDF;AAID;AACF;;AACD,SAAA,SAAA;AACD;;AAGD,SAAA,qBAAA,CAAA,MAAA,EAAA,UAAA,EAAA,KAAA,EAAA,MAAA,EAAkE;AAChE,OAAK,IAAL,eAAA,IAA8BvC,MAAM,CAApC,YAAA,EAAmD;AACjD,QAAI0C,eAAe,IAAnB,UAAA,EAAmC;AACjC1C,MAAAA,MAAM,CAANA,YAAAA,CAAAA,eAAAA,EAAAA,IAAAA,CAA0Cd,UAAU,CAApDc,eAAoD,CAApDA,EAAAA,KAAAA,EAA8E2C,KAAK,GAAnF3C,MAAAA;AACD;AACF;AACF;;AAGD,SAAA,oBAAA,CAAA,UAAA,EAAA,WAAA,EAAuD;AACrD,MAAM4C,KAAK,GAAX,EAAA;;AACA,OAAK,IAAL,GAAA,IAAA,UAAA,EAA8B;AAC5B,QAAI,CAACC,WAAW,CAAXA,QAAAA,CAAL,GAAKA,CAAL,EAAgC;AAC9BD,MAAAA,KAAK,CAALA,GAAK,CAALA,GAAa1D,UAAU,CAAvB0D,GAAuB,CAAvBA;AACD;AACF;;AACD,SAAA,KAAA;AACD;;AAED,SAAA,SAAA,CAAA,CAAA,EAAsB;AACpB,SAAOE,MAAM,CAANA,QAAAA,CAAP,CAAOA,CAAP;AACD","sourcesContent":["// @ts-nocheck\nimport {earcut} from '@math.gl/polygon';\n\n/**\n * Convert binary features to flat binary arrays. Similar to\n * `geojsonToBinary` helper function, except that it expects\n * a binary representation of the feature data, which enables\n * 2X-3X speed increase in parse speed, compared to using\n * geoJSON. See `binary-vector-tile/VectorTileFeature` for\n * data format detais\n */\nexport function featuresToBinary(features, firstPassData, options = {}) {\n  return fillArrays(features, firstPassData, {\n    numericPropKeys: options.numericPropKeys || extractNumericPropKeys(features),\n    PositionDataType: options.PositionDataType || Float32Array\n  });\n}\n\nexport const TEST_EXPORTS = {\n  extractNumericPropKeys,\n  fillArrays\n};\n\n// Extracts properties that are always numeric\n// eslint-disable-next-line complexity, max-statements\nfunction extractNumericPropKeys(features) {\n  const numericPropKeys = {};\n  for (const feature of features) {\n    if (feature.properties) {\n      for (const key in feature.properties) {\n        // If property has not been seen before, or if property has been numeric\n        // in all previous features, check if numeric in this feature\n        // If not numeric, false is stored to prevent rechecking in the future\n        const numericSoFar = numericPropKeys[key];\n        // eslint-disable-next-line max-depth\n        if (numericSoFar || numericSoFar === undefined) {\n          const val = feature.properties[key];\n          numericPropKeys[key] = isNumeric(val);\n        }\n      }\n    }\n  }\n\n  return Object.keys(numericPropKeys).filter((k) => numericPropKeys[k]);\n}\n\n// Fills coordinates into pre-allocated typed arrays\n// eslint-disable-next-line complexity\nfunction fillArrays(features, firstPassData = {}, options = {}) {\n  const {\n    pointPositionsCount,\n    pointFeaturesCount,\n    linePositionsCount,\n    linePathsCount,\n    lineFeaturesCount,\n    polygonPositionsCount,\n    polygonObjectsCount,\n    polygonRingsCount,\n    polygonFeaturesCount\n  } = firstPassData;\n  const {numericPropKeys, PositionDataType = Float32Array} = options;\n  const hasGlobalId = features[0] && 'id' in features[0];\n  const coordLength = 2;\n  const GlobalFeatureIdsDataType = features.length > 65535 ? Uint32Array : Uint16Array;\n  const points = {\n    positions: new PositionDataType(pointPositionsCount * coordLength),\n    globalFeatureIds: new GlobalFeatureIdsDataType(pointPositionsCount),\n    featureIds:\n      pointFeaturesCount > 65535\n        ? new Uint32Array(pointPositionsCount)\n        : new Uint16Array(pointPositionsCount),\n    numericProps: {},\n    properties: [],\n    fields: []\n  };\n  const lines = {\n    pathIndices:\n      linePositionsCount > 65535\n        ? new Uint32Array(linePathsCount + 1)\n        : new Uint16Array(linePathsCount + 1),\n    positions: new PositionDataType(linePositionsCount * coordLength),\n    globalFeatureIds: new GlobalFeatureIdsDataType(linePositionsCount),\n    featureIds:\n      lineFeaturesCount > 65535\n        ? new Uint32Array(linePositionsCount)\n        : new Uint16Array(linePositionsCount),\n    numericProps: {},\n    properties: [],\n    fields: []\n  };\n  const polygons = {\n    polygonIndices:\n      polygonPositionsCount > 65535\n        ? new Uint32Array(polygonObjectsCount + 1)\n        : new Uint16Array(polygonObjectsCount + 1),\n    primitivePolygonIndices:\n      polygonPositionsCount > 65535\n        ? new Uint32Array(polygonRingsCount + 1)\n        : new Uint16Array(polygonRingsCount + 1),\n    positions: new PositionDataType(polygonPositionsCount * coordLength),\n    triangles: [],\n    globalFeatureIds: new GlobalFeatureIdsDataType(polygonPositionsCount),\n    featureIds:\n      polygonFeaturesCount > 65535\n        ? new Uint32Array(polygonPositionsCount)\n        : new Uint16Array(polygonPositionsCount),\n    numericProps: {},\n    properties: [],\n    fields: []\n  };\n\n  // Instantiate numeric properties arrays; one value per vertex\n  for (const object of [points, lines, polygons]) {\n    for (const propName of numericPropKeys) {\n      // If property has been numeric in all previous features in which the property existed, check\n      // if numeric in this feature\n      object.numericProps[propName] = new Float32Array(object.positions.length / coordLength);\n    }\n  }\n\n  // Set last element of path/polygon indices as positions length\n  lines.pathIndices[linePathsCount] = linePositionsCount;\n  polygons.polygonIndices[polygonObjectsCount] = polygonPositionsCount;\n  polygons.primitivePolygonIndices[polygonRingsCount] = polygonPositionsCount;\n\n  const indexMap = {\n    pointPosition: 0,\n    pointFeature: 0,\n    linePosition: 0,\n    linePath: 0,\n    lineFeature: 0,\n    polygonPosition: 0,\n    polygonObject: 0,\n    polygonRing: 0,\n    polygonFeature: 0,\n    feature: 0\n  };\n\n  for (const feature of features) {\n    const geometry = feature.geometry;\n    const properties = feature.properties || {};\n\n    switch (geometry.type) {\n      case 'Point':\n      case 'MultiPoint':\n        handlePoint(geometry, points, indexMap, coordLength, properties);\n        points.properties.push(keepStringProperties(properties, numericPropKeys));\n        if (hasGlobalId) {\n          points.fields.push({id: feature.id});\n        }\n        indexMap.pointFeature++;\n        break;\n      case 'LineString':\n      case 'MultiLineString':\n        handleLineString(geometry, lines, indexMap, coordLength, properties);\n        lines.properties.push(keepStringProperties(properties, numericPropKeys));\n        if (hasGlobalId) {\n          lines.fields.push({id: feature.id});\n        }\n        indexMap.lineFeature++;\n        break;\n      case 'Polygon':\n      case 'MultiPolygon':\n        handlePolygon(geometry, polygons, indexMap, coordLength, properties);\n        polygons.properties.push(keepStringProperties(properties, numericPropKeys));\n        if (hasGlobalId) {\n          polygons.fields.push({id: feature.id});\n        }\n        indexMap.polygonFeature++;\n        break;\n      default:\n        throw new Error('Invalid geometry type');\n    }\n\n    indexMap.feature++;\n  }\n\n  // Wrap each array in an accessor object with value and size keys\n  return makeAccessorObjects(points, lines, polygons, coordLength);\n}\n\n// Fills (Multi)Point coordinates into points object of arrays\nfunction handlePoint(geometry, points, indexMap, coordLength, properties) {\n  points.positions.set(geometry.data, indexMap.pointPosition * coordLength);\n\n  const nPositions = geometry.data.length / coordLength;\n  fillNumericProperties(points, properties, indexMap.pointPosition, nPositions);\n  points.globalFeatureIds.fill(\n    indexMap.feature,\n    indexMap.pointPosition,\n    indexMap.pointPosition + nPositions\n  );\n  points.featureIds.fill(\n    indexMap.pointFeature,\n    indexMap.pointPosition,\n    indexMap.pointPosition + nPositions\n  );\n\n  indexMap.pointPosition += nPositions;\n}\n\n// Fills (Multi)LineString coordinates into lines object of arrays\nfunction handleLineString(geometry, lines, indexMap, coordLength, properties) {\n  lines.positions.set(geometry.data, indexMap.linePosition * coordLength);\n\n  const nPositions = geometry.data.length / coordLength;\n  fillNumericProperties(lines, properties, indexMap.linePosition, nPositions);\n\n  lines.globalFeatureIds.fill(\n    indexMap.feature,\n    indexMap.linePosition,\n    indexMap.linePosition + nPositions\n  );\n  lines.featureIds.fill(\n    indexMap.lineFeature,\n    indexMap.linePosition,\n    indexMap.linePosition + nPositions\n  );\n\n  for (let i = 0, il = geometry.lines.length; i < il; ++i) {\n    // Extract range of data we are working with, defined by start\n    // and end indices (these index into the geometry.data array)\n    const start = geometry.lines[i];\n    const end =\n      i === il - 1\n        ? geometry.data.length // last line, so read to end of data\n        : geometry.lines[i + 1]; // start index for next line\n\n    lines.pathIndices[indexMap.linePath++] = indexMap.linePosition;\n    indexMap.linePosition += (end - start) / coordLength;\n  }\n}\n\n// Fills (Multi)Polygon coordinates into polygons object of arrays\nfunction handlePolygon(geometry, polygons, indexMap, coordLength, properties) {\n  polygons.positions.set(geometry.data, indexMap.polygonPosition * coordLength);\n\n  const nPositions = geometry.data.length / coordLength;\n  fillNumericProperties(polygons, properties, indexMap.polygonPosition, nPositions);\n  polygons.globalFeatureIds.fill(\n    indexMap.feature,\n    indexMap.polygonPosition,\n    indexMap.polygonPosition + nPositions\n  );\n  polygons.featureIds.fill(\n    indexMap.polygonFeature,\n    indexMap.polygonPosition,\n    indexMap.polygonPosition + nPositions\n  );\n\n  // Unlike Point & LineString geometry.lines is a 2D array\n  for (let l = 0, ll = geometry.lines.length; l < ll; ++l) {\n    const startPosition = indexMap.polygonPosition;\n    polygons.polygonIndices[indexMap.polygonObject++] = startPosition;\n\n    const areas = geometry.areas[l];\n    const lines = geometry.lines[l];\n    const nextLines = geometry.lines[l + 1];\n\n    for (let i = 0, il = lines.length; i < il; ++i) {\n      const start = lines[i];\n      const end =\n        i === il - 1\n          ? // last line, so either read to:\n            nextLines === undefined\n            ? geometry.data.length // end of data (no next lines)\n            : nextLines[0] // start of first line in nextLines\n          : lines[i + 1]; // start index for next line\n\n      polygons.primitivePolygonIndices[indexMap.polygonRing++] = indexMap.polygonPosition;\n      indexMap.polygonPosition += (end - start) / coordLength;\n    }\n\n    const endPosition = indexMap.polygonPosition;\n    triangulatePolygon(polygons, areas, lines, {startPosition, endPosition, coordLength});\n  }\n}\n\n/**\n * Triangulate polygon using earcut\n */\nfunction triangulatePolygon(polygons, areas, lines, {startPosition, endPosition, coordLength}) {\n  const start = startPosition * coordLength;\n  const end = endPosition * coordLength;\n\n  // Extract positions and holes for just this polygon\n  const polygonPositions = polygons.positions.subarray(start, end);\n\n  // Holes are referenced relative to outer polygon\n  const offset = lines[0];\n  const holes = lines.slice(1).map((n) => (n - offset) / coordLength);\n\n  // Compute triangulation\n  const indices = earcut(polygonPositions, holes, coordLength, areas);\n\n  // Indices returned by triangulation are relative to start\n  // of polygon, so we need to offset\n  for (let t = 0, tl = indices.length; t < tl; ++t) {\n    polygons.triangles.push(startPosition + indices[t]);\n  }\n}\n\n// Wrap each array in an accessor object with value and size keys\nfunction makeAccessorObjects(points, lines, polygons, coordLength) {\n  const returnObj = {\n    points: {\n      ...points,\n      positions: {value: points.positions, size: coordLength},\n      globalFeatureIds: {value: points.globalFeatureIds, size: 1},\n      featureIds: {value: points.featureIds, size: 1}\n    },\n    lines: {\n      ...lines,\n      pathIndices: {value: lines.pathIndices, size: 1},\n      positions: {value: lines.positions, size: coordLength},\n      globalFeatureIds: {value: lines.globalFeatureIds, size: 1},\n      featureIds: {value: lines.featureIds, size: 1}\n    },\n    polygons: {\n      ...polygons,\n      polygonIndices: {value: polygons.polygonIndices, size: 1},\n      primitivePolygonIndices: {value: polygons.primitivePolygonIndices, size: 1},\n      positions: {value: polygons.positions, size: coordLength},\n      triangles: {value: new Uint32Array(polygons.triangles), size: 1},\n      globalFeatureIds: {value: polygons.globalFeatureIds, size: 1},\n      featureIds: {value: polygons.featureIds, size: 1}\n    }\n  };\n\n  for (const geomType in returnObj) {\n    for (const numericProp in returnObj[geomType].numericProps) {\n      returnObj[geomType].numericProps[numericProp] = {\n        value: returnObj[geomType].numericProps[numericProp],\n        size: 1\n      };\n    }\n  }\n  return returnObj;\n}\n\n// Add numeric properties to object\nfunction fillNumericProperties(object, properties, index, length) {\n  for (const numericPropName in object.numericProps) {\n    if (numericPropName in properties) {\n      object.numericProps[numericPropName].fill(properties[numericPropName], index, index + length);\n    }\n  }\n}\n\n// Keep string properties in object\nfunction keepStringProperties(properties, numericKeys) {\n  const props = {};\n  for (const key in properties) {\n    if (!numericKeys.includes(key)) {\n      props[key] = properties[key];\n    }\n  }\n  return props;\n}\n\nfunction isNumeric(x) {\n  return Number.isFinite(x);\n}\n"]},"metadata":{},"sourceType":"module"}