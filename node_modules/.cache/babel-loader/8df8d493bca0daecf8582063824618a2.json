{"ast":null,"code":"import _defineProperty from \"C:/Users/ESG-dell/Documents/Dev/Hachathon-miasta/PTA-frontend/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _objectSpread from \"C:/Users/ESG-dell/Documents/Dev/Hachathon-miasta/PTA-frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _classCallCheck from \"C:/Users/ESG-dell/Documents/Dev/Hachathon-miasta/PTA-frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/Users/ESG-dell/Documents/Dev/Hachathon-miasta/PTA-frontend/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport BinSorter from './bin-sorter';\nimport { getScaleFunctionByScaleType } from './scale-utils';\nimport { getValueFunc, wrapGetValueFunc } from './aggregation-operation-utils';\n\nfunction nop() {}\n\nvar dimensionSteps = ['getBins', 'getDomain', 'getScaleFunc'];\nvar _defaultDimensions = [{\n  key: 'fillColor',\n  accessor: 'getFillColor',\n  pickingInfo: 'colorValue',\n  getBins: {\n    triggers: {\n      value: {\n        prop: 'getColorValue',\n        updateTrigger: 'getColorValue'\n      },\n      weight: {\n        prop: 'getColorWeight',\n        updateTrigger: 'getColorWeight'\n      },\n      aggregation: {\n        prop: 'colorAggregation'\n      },\n      filterData: {\n        prop: '_filterData',\n        updateTrigger: '_filterData'\n      }\n    }\n  },\n  getDomain: {\n    triggers: {\n      lowerPercentile: {\n        prop: 'lowerPercentile'\n      },\n      upperPercentile: {\n        prop: 'upperPercentile'\n      },\n      scaleType: {\n        prop: 'colorScaleType'\n      }\n    }\n  },\n  getScaleFunc: {\n    triggers: {\n      domain: {\n        prop: 'colorDomain'\n      },\n      range: {\n        prop: 'colorRange'\n      }\n    },\n    onSet: {\n      props: 'onSetColorDomain'\n    }\n  },\n  nullValue: [0, 0, 0, 0]\n}, {\n  key: 'elevation',\n  accessor: 'getElevation',\n  pickingInfo: 'elevationValue',\n  getBins: {\n    triggers: {\n      value: {\n        prop: 'getElevationValue',\n        updateTrigger: 'getElevationValue'\n      },\n      weight: {\n        prop: 'getElevationWeight',\n        updateTrigger: 'getElevationWeight'\n      },\n      aggregation: {\n        prop: 'elevationAggregation'\n      },\n      filterData: {\n        prop: '_filterData',\n        updateTrigger: '_filterData'\n      }\n    }\n  },\n  getDomain: {\n    triggers: {\n      lowerPercentile: {\n        prop: 'elevationLowerPercentile'\n      },\n      upperPercentile: {\n        prop: 'elevationUpperPercentile'\n      },\n      scaleType: {\n        prop: 'elevationScaleType'\n      }\n    }\n  },\n  getScaleFunc: {\n    triggers: {\n      domain: {\n        prop: 'elevationDomain'\n      },\n      range: {\n        prop: 'elevationRange'\n      }\n    },\n    onSet: {\n      props: 'onSetElevationDomain'\n    }\n  },\n  nullValue: -1\n}];\n\nvar defaultGetCellSize = function defaultGetCellSize(props) {\n  return props.cellSize;\n};\n\nvar CPUAggregator = /*#__PURE__*/function () {\n  function CPUAggregator(opts) {\n    _classCallCheck(this, CPUAggregator);\n\n    this.state = {\n      layerData: {},\n      dimensions: {}\n    };\n    this.changeFlags = {};\n    this.dimensionUpdaters = {};\n    this._getCellSize = opts.getCellSize || defaultGetCellSize;\n    this._getAggregator = opts.getAggregator;\n\n    this._addDimension(opts.dimensions || _defaultDimensions);\n  }\n\n  _createClass(CPUAggregator, [{\n    key: \"updateState\",\n    value: function updateState(opts, aggregationParams) {\n      var oldProps = opts.oldProps,\n          props = opts.props,\n          changeFlags = opts.changeFlags;\n      this.updateGetValueFuncs(oldProps, props, changeFlags);\n      var reprojectNeeded = this.needsReProjectPoints(oldProps, props, changeFlags);\n      var aggregationDirty = false;\n\n      if (changeFlags.dataChanged || reprojectNeeded) {\n        this.getAggregatedData(props, aggregationParams);\n        aggregationDirty = true;\n      } else {\n        var dimensionChanges = this.getDimensionChanges(oldProps, props, changeFlags) || [];\n        dimensionChanges.forEach(function (f) {\n          return typeof f === 'function' && f();\n        });\n        aggregationDirty = true;\n      }\n\n      this.setState({\n        aggregationDirty: aggregationDirty\n      });\n      return this.state;\n    }\n  }, {\n    key: \"setState\",\n    value: function setState(updateObject) {\n      this.state = _objectSpread(_objectSpread({}, this.state), updateObject);\n    }\n  }, {\n    key: \"setDimensionState\",\n    value: function setDimensionState(key, updateObject) {\n      this.setState({\n        dimensions: _objectSpread(_objectSpread({}, this.state.dimensions), {}, _defineProperty({}, key, _objectSpread(_objectSpread({}, this.state.dimensions[key]), updateObject)))\n      });\n    }\n  }, {\n    key: \"normalizeResult\",\n    value: function normalizeResult() {\n      var result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (result.hexagons) {\n        return _objectSpread({\n          data: result.hexagons\n        }, result);\n      } else if (result.layerData) {\n        return _objectSpread({\n          data: result.layerData\n        }, result);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"getAggregatedData\",\n    value: function getAggregatedData(props, aggregationParams) {\n      var aggregator = this._getAggregator(props);\n\n      var result = aggregator(props, aggregationParams);\n      this.setState({\n        layerData: this.normalizeResult(result)\n      });\n      this.changeFlags = {\n        layerData: true\n      };\n      this.getSortedBins(props);\n    }\n  }, {\n    key: \"updateGetValueFuncs\",\n    value: function updateGetValueFuncs(oldProps, props, changeFlags) {\n      for (var key in this.dimensionUpdaters) {\n        var _this$dimensionUpdate = this.dimensionUpdaters[key].getBins.triggers,\n            value = _this$dimensionUpdate.value,\n            weight = _this$dimensionUpdate.weight,\n            aggregation = _this$dimensionUpdate.aggregation;\n        var getValue = props[value.prop];\n        var getValueChanged = this.needUpdateDimensionStep(this.dimensionUpdaters[key].getBins, oldProps, props, changeFlags);\n\n        if (getValueChanged) {\n          if (getValue) {\n            getValue = wrapGetValueFunc(getValue, {\n              data: props.data\n            });\n          } else {\n            getValue = getValueFunc(props[aggregation.prop], props[weight.prop], {\n              data: props.data\n            });\n          }\n        }\n\n        if (getValue) {\n          this.setDimensionState(key, {\n            getValue: getValue\n          });\n        }\n      }\n    }\n  }, {\n    key: \"needsReProjectPoints\",\n    value: function needsReProjectPoints(oldProps, props, changeFlags) {\n      return this._getCellSize(oldProps) !== this._getCellSize(props) || this._getAggregator(oldProps) !== this._getAggregator(props) || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPosition);\n    }\n  }, {\n    key: \"addDimension\",\n    value: function addDimension(dimensions) {\n      this._addDimension(dimensions);\n    }\n  }, {\n    key: \"_addDimension\",\n    value: function _addDimension() {\n      var _this = this;\n\n      var dimensions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      dimensions.forEach(function (dimension) {\n        var key = dimension.key;\n        _this.dimensionUpdaters[key] = _this.getDimensionUpdaters(dimension);\n        _this.state.dimensions[key] = {\n          getValue: null,\n          domain: null,\n          sortedBins: null,\n          scaleFunc: nop\n        };\n      });\n    }\n  }, {\n    key: \"getDimensionUpdaters\",\n    value: function getDimensionUpdaters(_ref) {\n      var key = _ref.key,\n          accessor = _ref.accessor,\n          pickingInfo = _ref.pickingInfo,\n          getBins = _ref.getBins,\n          getDomain = _ref.getDomain,\n          getScaleFunc = _ref.getScaleFunc,\n          nullValue = _ref.nullValue;\n      return {\n        key: key,\n        accessor: accessor,\n        pickingInfo: pickingInfo,\n        getBins: _objectSpread({\n          updater: this.getDimensionSortedBins\n        }, getBins),\n        getDomain: _objectSpread({\n          updater: this.getDimensionValueDomain\n        }, getDomain),\n        getScaleFunc: _objectSpread({\n          updater: this.getDimensionScale\n        }, getScaleFunc),\n        attributeAccessor: this.getSubLayerDimensionAttribute(key, nullValue)\n      };\n    }\n  }, {\n    key: \"needUpdateDimensionStep\",\n    value: function needUpdateDimensionStep(dimensionStep, oldProps, props, changeFlags) {\n      return Object.values(dimensionStep.triggers).some(function (item) {\n        if (item.updateTrigger) {\n          return changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged[item.updateTrigger]);\n        }\n\n        return oldProps[item.prop] !== props[item.prop];\n      });\n    }\n  }, {\n    key: \"getDimensionChanges\",\n    value: function getDimensionChanges(oldProps, props, changeFlags) {\n      var _this2 = this;\n\n      var updaters = [];\n\n      var _loop = function _loop(key) {\n        var needUpdate = dimensionSteps.find(function (step) {\n          return _this2.needUpdateDimensionStep(_this2.dimensionUpdaters[key][step], oldProps, props, changeFlags);\n        });\n\n        if (needUpdate) {\n          updaters.push(_this2.dimensionUpdaters[key][needUpdate].updater.bind(_this2, props, _this2.dimensionUpdaters[key]));\n        }\n      };\n\n      for (var key in this.dimensionUpdaters) {\n        _loop(key);\n      }\n\n      return updaters.length ? updaters : null;\n    }\n  }, {\n    key: \"getUpdateTriggers\",\n    value: function getUpdateTriggers(props) {\n      var _this3 = this;\n\n      var _updateTriggers = props.updateTriggers || {};\n\n      var updateTriggers = {};\n\n      var _loop2 = function _loop2(key) {\n        var accessor = _this3.dimensionUpdaters[key].accessor;\n        updateTriggers[accessor] = {};\n        dimensionSteps.forEach(function (step) {\n          Object.values(_this3.dimensionUpdaters[key][step].triggers).forEach(function (_ref2) {\n            var prop = _ref2.prop,\n                updateTrigger = _ref2.updateTrigger;\n\n            if (updateTrigger) {\n              var fromProp = _updateTriggers[updateTrigger];\n\n              if (typeof fromProp === 'object' && !Array.isArray(fromProp)) {\n                Object.assign(updateTriggers[accessor], fromProp);\n              } else if (fromProp !== undefined) {\n                updateTriggers[accessor][prop] = fromProp;\n              }\n            } else {\n              updateTriggers[accessor][prop] = props[prop];\n            }\n          });\n        });\n      };\n\n      for (var key in this.dimensionUpdaters) {\n        _loop2(key);\n      }\n\n      return updateTriggers;\n    }\n  }, {\n    key: \"getSortedBins\",\n    value: function getSortedBins(props) {\n      for (var key in this.dimensionUpdaters) {\n        this.getDimensionSortedBins(props, this.dimensionUpdaters[key]);\n      }\n    }\n  }, {\n    key: \"getDimensionSortedBins\",\n    value: function getDimensionSortedBins(props, dimensionUpdater) {\n      var key = dimensionUpdater.key;\n      var getValue = this.state.dimensions[key].getValue;\n      var sortedBins = new BinSorter(this.state.layerData.data || [], {\n        getValue: getValue,\n        filterData: props._filterData\n      });\n      this.setDimensionState(key, {\n        sortedBins: sortedBins\n      });\n      this.getDimensionValueDomain(props, dimensionUpdater);\n    }\n  }, {\n    key: \"getDimensionValueDomain\",\n    value: function getDimensionValueDomain(props, dimensionUpdater) {\n      var getDomain = dimensionUpdater.getDomain,\n          key = dimensionUpdater.key;\n      var _getDomain$triggers = getDomain.triggers,\n          lowerPercentile = _getDomain$triggers.lowerPercentile,\n          upperPercentile = _getDomain$triggers.upperPercentile,\n          scaleType = _getDomain$triggers.scaleType;\n      var valueDomain = this.state.dimensions[key].sortedBins.getValueDomainByScale(props[scaleType.prop], [props[lowerPercentile.prop], props[upperPercentile.prop]]);\n      this.setDimensionState(key, {\n        valueDomain: valueDomain\n      });\n      this.getDimensionScale(props, dimensionUpdater);\n    }\n  }, {\n    key: \"getDimensionScale\",\n    value: function getDimensionScale(props, dimensionUpdater) {\n      var key = dimensionUpdater.key,\n          getScaleFunc = dimensionUpdater.getScaleFunc,\n          getDomain = dimensionUpdater.getDomain;\n      var _getScaleFunc$trigger = getScaleFunc.triggers,\n          domain = _getScaleFunc$trigger.domain,\n          range = _getScaleFunc$trigger.range;\n      var scaleType = getDomain.triggers.scaleType;\n      var onSet = getScaleFunc.onSet;\n      var dimensionRange = props[range.prop];\n      var dimensionDomain = props[domain.prop] || this.state.dimensions[key].valueDomain;\n      var getScaleFunction = getScaleFunctionByScaleType(scaleType && props[scaleType.prop]);\n      var scaleFunc = getScaleFunction(dimensionDomain, dimensionRange);\n\n      if (typeof onSet === 'object' && typeof props[onSet.props] === 'function') {\n        props[onSet.props](scaleFunc.domain());\n      }\n\n      this.setDimensionState(key, {\n        scaleFunc: scaleFunc\n      });\n    }\n  }, {\n    key: \"getSubLayerDimensionAttribute\",\n    value: function getSubLayerDimensionAttribute(key, nullValue) {\n      var _this4 = this;\n\n      return function (cell) {\n        var _this4$state$dimensio = _this4.state.dimensions[key],\n            sortedBins = _this4$state$dimensio.sortedBins,\n            scaleFunc = _this4$state$dimensio.scaleFunc;\n        var bin = sortedBins.binMap[cell.index];\n\n        if (bin && bin.counts === 0) {\n          return nullValue;\n        }\n\n        var cv = bin && bin.value;\n        var domain = scaleFunc.domain();\n        var isValueInDomain = cv >= domain[0] && cv <= domain[domain.length - 1];\n        return isValueInDomain ? scaleFunc(cv) : nullValue;\n      };\n    }\n  }, {\n    key: \"getSubLayerAccessors\",\n    value: function getSubLayerAccessors(props) {\n      var accessors = {};\n\n      for (var key in this.dimensionUpdaters) {\n        var accessor = this.dimensionUpdaters[key].accessor;\n        accessors[accessor] = this.getSubLayerDimensionAttribute(props, key);\n      }\n\n      return accessors;\n    }\n  }, {\n    key: \"getPickingInfo\",\n    value: function getPickingInfo(_ref3) {\n      var info = _ref3.info;\n      var isPicked = info.picked && info.index > -1;\n      var object = null;\n\n      if (isPicked) {\n        var cell = this.state.layerData.data[info.index];\n        var binInfo = {};\n\n        for (var key in this.dimensionUpdaters) {\n          var pickingInfo = this.dimensionUpdaters[key].pickingInfo;\n          var sortedBins = this.state.dimensions[key].sortedBins;\n          var value = sortedBins.binMap[cell.index] && sortedBins.binMap[cell.index].value;\n          binInfo[pickingInfo] = value;\n        }\n\n        object = Object.assign(binInfo, cell, {\n          points: cell.filteredPoints || cell.points\n        });\n      }\n\n      info.picked = Boolean(object);\n      info.object = object;\n      return info;\n    }\n  }, {\n    key: \"getAccessor\",\n    value: function getAccessor(dimensionKey) {\n      if (!this.dimensionUpdaters.hasOwnProperty(dimensionKey)) {\n        return nop;\n      }\n\n      return this.dimensionUpdaters[dimensionKey].attributeAccessor;\n    }\n  }], [{\n    key: \"defaultDimensions\",\n    value: function defaultDimensions() {\n      return _defaultDimensions;\n    }\n  }]);\n\n  return CPUAggregator;\n}();\n\nexport { CPUAggregator as default };","map":{"version":3,"sources":["../../../src/utils/cpu-aggregator.js"],"names":["dimensionSteps","defaultDimensions","key","accessor","pickingInfo","getBins","triggers","value","prop","updateTrigger","weight","aggregation","filterData","getDomain","lowerPercentile","upperPercentile","scaleType","getScaleFunc","domain","range","onSet","props","nullValue","defaultGetCellSize","constructor","layerData","dimensions","opts","updateState","changeFlags","reprojectNeeded","aggregationDirty","dimensionChanges","f","setState","updateObject","setDimensionState","normalizeResult","result","data","getAggregatedData","aggregator","updateGetValueFuncs","getValue","getValueChanged","wrapGetValueFunc","getValueFunc","needsReProjectPoints","addDimension","_addDimension","dimension","sortedBins","scaleFunc","nop","getDimensionUpdaters","updater","attributeAccessor","needUpdateDimensionStep","dimensionStep","item","oldProps","getDimensionChanges","updaters","needUpdate","step","getUpdateTriggers","_updateTriggers","updateTriggers","Object","fromProp","Array","getSortedBins","getDimensionSortedBins","_filterData","getDimensionValueDomain","valueDomain","getDimensionScale","dimensionRange","dimensionDomain","getScaleFunction","getScaleFunctionByScaleType","getSubLayerDimensionAttribute","cell","bin","cv","isValueInDomain","getSubLayerAccessors","accessors","getPickingInfo","info","isPicked","object","binInfo","points","Boolean","getAccessor"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport BinSorter from './bin-sorter';\nimport {getScaleFunctionByScaleType} from './scale-utils';\nimport {getValueFunc, wrapGetValueFunc} from './aggregation-operation-utils';\n\nfunction nop() {}\n\nconst dimensionSteps = ['getBins', 'getDomain', 'getScaleFunc'];\nconst defaultDimensions = [\n  {\n    key: 'fillColor',\n    accessor: 'getFillColor',\n    pickingInfo: 'colorValue',\n    getBins: {\n      triggers: {\n        value: {\n          prop: 'getColorValue',\n          updateTrigger: 'getColorValue'\n        },\n        weight: {\n          prop: 'getColorWeight',\n          updateTrigger: 'getColorWeight'\n        },\n        aggregation: {\n          prop: 'colorAggregation'\n        },\n        filterData: {\n          prop: '_filterData',\n          updateTrigger: '_filterData'\n        }\n      }\n    },\n    getDomain: {\n      triggers: {\n        lowerPercentile: {\n          prop: 'lowerPercentile'\n        },\n        upperPercentile: {\n          prop: 'upperPercentile'\n        },\n        scaleType: {\n          prop: 'colorScaleType'\n        }\n      }\n    },\n    getScaleFunc: {\n      triggers: {\n        domain: {prop: 'colorDomain'},\n        range: {prop: 'colorRange'}\n      },\n      onSet: {\n        props: 'onSetColorDomain'\n      }\n    },\n    nullValue: [0, 0, 0, 0]\n  },\n  {\n    key: 'elevation',\n    accessor: 'getElevation',\n    pickingInfo: 'elevationValue',\n    getBins: {\n      triggers: {\n        value: {\n          prop: 'getElevationValue',\n          updateTrigger: 'getElevationValue'\n        },\n        weight: {\n          prop: 'getElevationWeight',\n          updateTrigger: 'getElevationWeight'\n        },\n        aggregation: {\n          prop: 'elevationAggregation'\n        },\n        filterData: {\n          prop: '_filterData',\n          updateTrigger: '_filterData'\n        }\n      }\n    },\n    getDomain: {\n      triggers: {\n        lowerPercentile: {\n          prop: 'elevationLowerPercentile'\n        },\n        upperPercentile: {\n          prop: 'elevationUpperPercentile'\n        },\n        scaleType: {\n          prop: 'elevationScaleType'\n        }\n      }\n    },\n    getScaleFunc: {\n      triggers: {\n        domain: {prop: 'elevationDomain'},\n        range: {prop: 'elevationRange'}\n      },\n      onSet: {\n        props: 'onSetElevationDomain'\n      }\n    },\n    nullValue: -1\n  }\n];\nconst defaultGetCellSize = props => props.cellSize;\nexport default class CPUAggregator {\n  constructor(opts) {\n    this.state = {\n      layerData: {},\n      dimensions: {\n        // color: {\n        //   getValue: null,\n        //   domain: null,\n        //   sortedBins: null,\n        //   scaleFunc: nop\n        // },\n        // elevation: {\n        //   getValue: null,\n        //   domain: null,\n        //   sortedBins: null,\n        //   scaleFunc: nop\n        // }\n      }\n    };\n    this.changeFlags = {};\n    this.dimensionUpdaters = {};\n\n    this._getCellSize = opts.getCellSize || defaultGetCellSize;\n    this._getAggregator = opts.getAggregator;\n    this._addDimension(opts.dimensions || defaultDimensions);\n  }\n\n  static defaultDimensions() {\n    return defaultDimensions;\n  }\n\n  updateState(opts, aggregationParams) {\n    const {oldProps, props, changeFlags} = opts;\n    this.updateGetValueFuncs(oldProps, props, changeFlags);\n    const reprojectNeeded = this.needsReProjectPoints(oldProps, props, changeFlags);\n    let aggregationDirty = false;\n    if (changeFlags.dataChanged || reprojectNeeded) {\n      // project data into bin and aggregate wegiths per bin\n      this.getAggregatedData(props, aggregationParams);\n      aggregationDirty = true;\n    } else {\n      const dimensionChanges = this.getDimensionChanges(oldProps, props, changeFlags) || [];\n      // this here is layer\n      dimensionChanges.forEach(f => typeof f === 'function' && f());\n      aggregationDirty = true;\n    }\n    this.setState({aggregationDirty});\n\n    return this.state;\n  }\n\n  // Update private state\n  setState(updateObject) {\n    this.state = {...this.state, ...updateObject};\n  }\n\n  // Update private state.dimensions\n  setDimensionState(key, updateObject) {\n    this.setState({\n      dimensions: {\n        ...this.state.dimensions,\n        [key]: {...this.state.dimensions[key], ...updateObject}\n      }\n    });\n  }\n\n  normalizeResult(result = {}) {\n    // support previous hexagonAggregator API\n    if (result.hexagons) {\n      return {data: result.hexagons, ...result};\n    } else if (result.layerData) {\n      return {data: result.layerData, ...result};\n    }\n\n    return result;\n  }\n\n  getAggregatedData(props, aggregationParams) {\n    const aggregator = this._getAggregator(props);\n\n    const result = aggregator(props, aggregationParams);\n    this.setState({\n      layerData: this.normalizeResult(result)\n    });\n    this.changeFlags = {\n      layerData: true\n    };\n    this.getSortedBins(props);\n  }\n\n  updateGetValueFuncs(oldProps, props, changeFlags) {\n    for (const key in this.dimensionUpdaters) {\n      const {value, weight, aggregation} = this.dimensionUpdaters[key].getBins.triggers;\n      let getValue = props[value.prop];\n      const getValueChanged = this.needUpdateDimensionStep(\n        this.dimensionUpdaters[key].getBins,\n        oldProps,\n        props,\n        changeFlags\n      );\n\n      if (getValueChanged) {\n        if (getValue) {\n          getValue = wrapGetValueFunc(getValue, {data: props.data});\n        } else {\n          // If `getValue` is not provided from props, build it with aggregation and weight.\n          getValue = getValueFunc(props[aggregation.prop], props[weight.prop], {data: props.data});\n        }\n      }\n\n      if (getValue) {\n        this.setDimensionState(key, {getValue});\n      }\n    }\n  }\n\n  needsReProjectPoints(oldProps, props, changeFlags) {\n    return (\n      this._getCellSize(oldProps) !== this._getCellSize(props) ||\n      this._getAggregator(oldProps) !== this._getAggregator(props) ||\n      (changeFlags.updateTriggersChanged &&\n        (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPosition))\n    );\n  }\n\n  // Adds dimensions\n  addDimension(dimensions) {\n    this._addDimension(dimensions);\n  }\n\n  _addDimension(dimensions = []) {\n    dimensions.forEach(dimension => {\n      const {key} = dimension;\n      this.dimensionUpdaters[key] = this.getDimensionUpdaters(dimension);\n      this.state.dimensions[key] = {\n        getValue: null,\n        domain: null,\n        sortedBins: null,\n        scaleFunc: nop\n      };\n    });\n  }\n\n  getDimensionUpdaters({key, accessor, pickingInfo, getBins, getDomain, getScaleFunc, nullValue}) {\n    return {\n      key,\n      accessor,\n      pickingInfo,\n      getBins: {updater: this.getDimensionSortedBins, ...getBins},\n      getDomain: {updater: this.getDimensionValueDomain, ...getDomain},\n      getScaleFunc: {updater: this.getDimensionScale, ...getScaleFunc},\n      attributeAccessor: this.getSubLayerDimensionAttribute(key, nullValue)\n    };\n  }\n\n  needUpdateDimensionStep(dimensionStep, oldProps, props, changeFlags) {\n    // whether need to update current dimension step\n    // dimension step is the value, domain, scaleFunction of each dimension\n    // each step is an object with properties links to layer prop and whether the prop is\n    // controlled by updateTriggers\n    // getBins: {\n    //   value: {\n    //     prop: 'getElevationValue',\n    //     updateTrigger: 'getElevationValue'\n    //   },\n    //   weight: {\n    //     prop: 'getElevationWeight',\n    //     updateTrigger: 'getElevationWeight'\n    //   },\n    //   aggregation: {\n    //     prop: 'elevationAggregation'\n    //   }\n    // }\n    return Object.values(dimensionStep.triggers).some(item => {\n      if (item.updateTrigger) {\n        // check based on updateTriggers change first\n        // if data has changed, always update value\n        return (\n          changeFlags.dataChanged ||\n          (changeFlags.updateTriggersChanged &&\n            (changeFlags.updateTriggersChanged.all ||\n              changeFlags.updateTriggersChanged[item.updateTrigger]))\n        );\n      }\n      // fallback to direct comparison\n      return oldProps[item.prop] !== props[item.prop];\n    });\n  }\n\n  getDimensionChanges(oldProps, props, changeFlags) {\n    // const {dimensionUpdaters} = this.state;\n    const updaters = [];\n\n    // get dimension to be updated\n    for (const key in this.dimensionUpdaters) {\n      // return the first triggered updater for each dimension\n      const needUpdate = dimensionSteps.find(step =>\n        this.needUpdateDimensionStep(\n          this.dimensionUpdaters[key][step],\n          oldProps,\n          props,\n          changeFlags\n        )\n      );\n\n      if (needUpdate) {\n        updaters.push(\n          this.dimensionUpdaters[key][needUpdate].updater.bind(\n            this,\n            props,\n            this.dimensionUpdaters[key]\n          )\n        );\n      }\n    }\n\n    return updaters.length ? updaters : null;\n  }\n\n  getUpdateTriggers(props) {\n    const _updateTriggers = props.updateTriggers || {};\n    const updateTriggers = {};\n\n    for (const key in this.dimensionUpdaters) {\n      const {accessor} = this.dimensionUpdaters[key];\n      // fold dimension triggers into each accessor\n      updateTriggers[accessor] = {};\n\n      dimensionSteps.forEach(step => {\n        Object.values(this.dimensionUpdaters[key][step].triggers).forEach(\n          ({prop, updateTrigger}) => {\n            if (updateTrigger) {\n              // if prop is based on updateTrigger e.g. getColorValue, getColorWeight\n              // and updateTriggers is passed in from layer prop\n              // fold the updateTriggers into accessor\n              const fromProp = _updateTriggers[updateTrigger];\n              if (typeof fromProp === 'object' && !Array.isArray(fromProp)) {\n                // if updateTrigger is an object spread it\n                Object.assign(updateTriggers[accessor], fromProp);\n              } else if (fromProp !== undefined) {\n                updateTriggers[accessor][prop] = fromProp;\n              }\n            } else {\n              // if prop is not based on updateTrigger\n              updateTriggers[accessor][prop] = props[prop];\n            }\n          }\n        );\n      });\n    }\n\n    return updateTriggers;\n  }\n\n  getSortedBins(props) {\n    for (const key in this.dimensionUpdaters) {\n      this.getDimensionSortedBins(props, this.dimensionUpdaters[key]);\n    }\n  }\n\n  getDimensionSortedBins(props, dimensionUpdater) {\n    const {key} = dimensionUpdater;\n    const {getValue} = this.state.dimensions[key];\n\n    const sortedBins = new BinSorter(this.state.layerData.data || [], {\n      getValue,\n      filterData: props._filterData\n    });\n    this.setDimensionState(key, {sortedBins});\n    this.getDimensionValueDomain(props, dimensionUpdater);\n  }\n\n  getDimensionValueDomain(props, dimensionUpdater) {\n    const {getDomain, key} = dimensionUpdater;\n    const {\n      triggers: {lowerPercentile, upperPercentile, scaleType}\n    } = getDomain;\n    const valueDomain = this.state.dimensions[key].sortedBins.getValueDomainByScale(\n      props[scaleType.prop],\n      [props[lowerPercentile.prop], props[upperPercentile.prop]]\n    );\n\n    this.setDimensionState(key, {valueDomain});\n    this.getDimensionScale(props, dimensionUpdater);\n  }\n\n  getDimensionScale(props, dimensionUpdater) {\n    const {key, getScaleFunc, getDomain} = dimensionUpdater;\n    const {domain, range} = getScaleFunc.triggers;\n    const {scaleType} = getDomain.triggers;\n    const {onSet} = getScaleFunc;\n    const dimensionRange = props[range.prop];\n    const dimensionDomain = props[domain.prop] || this.state.dimensions[key].valueDomain;\n    const getScaleFunction = getScaleFunctionByScaleType(scaleType && props[scaleType.prop]);\n    const scaleFunc = getScaleFunction(dimensionDomain, dimensionRange);\n\n    if (typeof onSet === 'object' && typeof props[onSet.props] === 'function') {\n      props[onSet.props](scaleFunc.domain());\n    }\n\n    this.setDimensionState(key, {scaleFunc});\n  }\n\n  getSubLayerDimensionAttribute(key, nullValue) {\n    return cell => {\n      const {sortedBins, scaleFunc} = this.state.dimensions[key];\n      const bin = sortedBins.binMap[cell.index];\n\n      if (bin && bin.counts === 0) {\n        // no points left in bin after filtering\n        return nullValue;\n      }\n      const cv = bin && bin.value;\n      const domain = scaleFunc.domain();\n\n      const isValueInDomain = cv >= domain[0] && cv <= domain[domain.length - 1];\n\n      // if cell value is outside domain, set alpha to 0\n      return isValueInDomain ? scaleFunc(cv) : nullValue;\n    };\n  }\n\n  getSubLayerAccessors(props) {\n    const accessors = {};\n    for (const key in this.dimensionUpdaters) {\n      const {accessor} = this.dimensionUpdaters[key];\n      accessors[accessor] = this.getSubLayerDimensionAttribute(props, key);\n    }\n\n    return accessors;\n  }\n\n  getPickingInfo({info}) {\n    const isPicked = info.picked && info.index > -1;\n    let object = null;\n\n    if (isPicked) {\n      // const {sortedColorBins, sortedElevationBins} = this.state;\n\n      const cell = this.state.layerData.data[info.index];\n\n      const binInfo = {};\n      for (const key in this.dimensionUpdaters) {\n        const {pickingInfo} = this.dimensionUpdaters[key];\n        const {sortedBins} = this.state.dimensions[key];\n        const value = sortedBins.binMap[cell.index] && sortedBins.binMap[cell.index].value;\n        binInfo[pickingInfo] = value;\n      }\n\n      object = Object.assign(binInfo, cell, {\n        points: cell.filteredPoints || cell.points\n      });\n    }\n\n    // override object with picked cell\n    info.picked = Boolean(object);\n    info.object = object;\n\n    return info;\n  }\n\n  getAccessor(dimensionKey) {\n    if (!this.dimensionUpdaters.hasOwnProperty(dimensionKey)) {\n      return nop;\n    }\n    return this.dimensionUpdaters[dimensionKey].attributeAccessor;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}