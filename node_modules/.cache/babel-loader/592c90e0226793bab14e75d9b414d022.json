{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/Users/ESG-dell/Documents/Dev/Hachathon-miasta/PTA-frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"C:/Users/ESG-dell/Documents/Dev/Hachathon-miasta/PTA-frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/Users/ESG-dell/Documents/Dev/Hachathon-miasta/PTA-frontend/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { getPolygonSignedArea } from '@math.gl/polygon';\nvar endPos, cmd, cmdLen, length, x, y, i;\nexport var TEST_EXPORTS = {\n  classifyRings: classifyRings\n};\n\nvar VectorTileFeature = /*#__PURE__*/function () {\n  function VectorTileFeature(pbf, end, extent, keys, values, firstPassData) {\n    _classCallCheck(this, VectorTileFeature);\n\n    this.properties = {};\n    this.extent = extent;\n    this.type = 0;\n    this.id = null;\n    this._pbf = pbf;\n    this._geometry = -1;\n    this._keys = keys;\n    this._values = values;\n    this._firstPassData = firstPassData;\n    pbf.readFields(readFeature, this, end);\n  }\n\n  _createClass(VectorTileFeature, [{\n    key: \"loadGeometry\",\n    value: function loadGeometry() {\n      var pbf = this._pbf;\n      pbf.pos = this._geometry;\n      endPos = pbf.readVarint() + pbf.pos;\n      cmd = 1;\n      length = 0;\n      x = 0;\n      y = 0;\n      i = 0;\n      var lines = [];\n      var data = [];\n\n      while (pbf.pos < endPos) {\n        if (length <= 0) {\n          cmdLen = pbf.readVarint();\n          cmd = cmdLen & 0x7;\n          length = cmdLen >> 3;\n        }\n\n        length--;\n\n        if (cmd === 1 || cmd === 2) {\n          x += pbf.readSVarint();\n          y += pbf.readSVarint();\n\n          if (cmd === 1) {\n            lines.push(i);\n          }\n\n          data.push(x, y);\n          i += 2;\n        } else if (cmd === 7) {\n          if (i > 0) {\n            var start = lines[lines.length - 1];\n            data.push(data[start], data[start + 1]);\n            i += 2;\n          }\n        } else {\n          throw new Error(\"unknown command \".concat(cmd));\n        }\n      }\n\n      return {\n        data: data,\n        lines: lines\n      };\n    }\n  }, {\n    key: \"_toBinaryCoordinates\",\n    value: function _toBinaryCoordinates(transform) {\n      var geom = this.loadGeometry();\n      transform(geom.data, this);\n      var coordLength = 2;\n\n      switch (this.type) {\n        case 1:\n          this._firstPassData.pointFeaturesCount++;\n          this._firstPassData.pointPositionsCount += geom.lines.length;\n          break;\n\n        case 2:\n          this._firstPassData.lineFeaturesCount++;\n          this._firstPassData.linePathsCount += geom.lines.length;\n          this._firstPassData.linePositionsCount += geom.data.length / coordLength;\n          break;\n\n        case 3:\n          var classified = classifyRings(geom);\n          this._firstPassData.polygonFeaturesCount++;\n          this._firstPassData.polygonObjectsCount += classified.lines.length;\n\n          var _iterator = _createForOfIteratorHelper(classified.lines),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var lines = _step.value;\n              this._firstPassData.polygonRingsCount += lines.length;\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n\n          this._firstPassData.polygonPositionsCount += classified.data.length / coordLength;\n          geom = classified;\n          break;\n      }\n\n      geom.type = VectorTileFeature.types[this.type];\n\n      if (geom.lines.length > 1) {\n        geom.type = \"Multi\".concat(geom.type);\n      }\n\n      var result = {\n        type: 'Feature',\n        geometry: geom,\n        properties: this.properties\n      };\n\n      if (this.id !== null) {\n        result.id = this.id;\n      }\n\n      return result;\n    }\n  }, {\n    key: \"toBinaryCoordinates\",\n    value: function toBinaryCoordinates(options) {\n      if (typeof options === 'function') {\n        return this._toBinaryCoordinates(options);\n      }\n\n      var x = options.x,\n          y = options.y,\n          z = options.z;\n      var size = this.extent * Math.pow(2, z);\n      var x0 = this.extent * x;\n      var y0 = this.extent * y;\n\n      function project(data) {\n        for (var j = 0, jl = data.length; j < jl; j += 2) {\n          data[j] = (data[j] + x0) * 360 / size - 180;\n          var y2 = 180 - (data[j + 1] + y0) * 360 / size;\n          data[j + 1] = 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;\n        }\n      }\n\n      return this._toBinaryCoordinates(project);\n    }\n  }], [{\n    key: \"types\",\n    get: function get() {\n      return ['Unknown', 'Point', 'LineString', 'Polygon'];\n    }\n  }]);\n\n  return VectorTileFeature;\n}();\n\nexport { VectorTileFeature as default };\n\nfunction classifyRings(geom) {\n  var len = geom.lines.length;\n\n  if (len <= 1) {\n    return {\n      data: geom.data,\n      areas: [[getPolygonSignedArea(geom.data)]],\n      lines: [geom.lines]\n    };\n  }\n\n  var areas = [];\n  var polygons = [];\n  var ringAreas;\n  var polygon;\n  var ccw;\n  var offset = 0;\n\n  for (var _i = 0, startIndex, endIndex; _i < len; _i++) {\n    startIndex = geom.lines[_i] - offset;\n    endIndex = geom.lines[_i + 1] - offset || geom.data.length;\n    var shape = geom.data.slice(startIndex, endIndex);\n    var area = getPolygonSignedArea(shape);\n\n    if (area === 0) {\n      var before = geom.data.slice(0, startIndex);\n      var after = geom.data.slice(endIndex);\n      geom.data = before.concat(after);\n      offset += endIndex - startIndex;\n      continue;\n    }\n\n    if (ccw === undefined) ccw = area < 0;\n\n    if (ccw === area < 0) {\n      if (polygon) {\n        areas.push(ringAreas);\n        polygons.push(polygon);\n      }\n\n      polygon = [startIndex];\n      ringAreas = [area];\n    } else {\n      ringAreas.push(area);\n      polygon.push(startIndex);\n    }\n  }\n\n  if (ringAreas) areas.push(ringAreas);\n  if (polygon) polygons.push(polygon);\n  return {\n    areas: areas,\n    lines: polygons,\n    data: geom.data\n  };\n}\n\nfunction readFeature(tag, feature, pbf) {\n  if (tag === 1) feature.id = pbf.readVarint();else if (tag === 2) readTag(pbf, feature);else if (tag === 3) feature.type = pbf.readVarint();else if (tag === 4) feature._geometry = pbf.pos;\n}\n\nfunction readTag(pbf, feature) {\n  var end = pbf.readVarint() + pbf.pos;\n\n  while (pbf.pos < end) {\n    var key = feature._keys[pbf.readVarint()];\n\n    var value = feature._values[pbf.readVarint()];\n\n    feature.properties[key] = value;\n  }\n}","map":{"version":3,"sources":["../../../../src/lib/binary-vector-tile/vector-tile-feature.js"],"names":["TEST_EXPORTS","classifyRings","types","constructor","pbf","loadGeometry","endPos","cmd","length","x","y","i","lines","data","cmdLen","start","_toBinaryCoordinates","geom","transform","coordLength","classified","VectorTileFeature","result","type","geometry","properties","toBinaryCoordinates","z","size","Math","x0","y0","j","jl","y2","len","areas","getPolygonSignedArea","polygons","offset","startIndex","endIndex","shape","area","before","after","ccw","polygon","ringAreas","tag","feature","readTag","end","key","value"],"mappings":";;;AAGA,SAAA,oBAAA,QAAA,kBAAA;AAGA,IAAA,MAAA,EAAA,GAAA,EAAA,MAAA,EAAA,MAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA;AAEA,OAAO,IAAMA,YAAY,GAAG;AAC1BC,EAAAA,aAAAA,EAAAA;AAD0B,CAArB;;IAIQ,iB;AAKbE,6BAAW,GAAXA,EAAW,GAAXA,EAAW,MAAXA,EAAW,IAAXA,EAAW,MAAXA,EAAW,aAAXA,EAA2D;AAAA;;AAEzD,SAAA,UAAA,GAAA,EAAA;AACA,SAAA,MAAA,GAAA,MAAA;AACA,SAAA,IAAA,GAAA,CAAA;AACA,SAAA,EAAA,GAAA,IAAA;AAGA,SAAA,IAAA,GAAA,GAAA;AACA,SAAA,SAAA,GAAiB,CAAjB,CAAA;AACA,SAAA,KAAA,GAAA,IAAA;AACA,SAAA,OAAA,GAAA,MAAA;AACA,SAAA,cAAA,GAAA,aAAA;AAEAC,IAAAA,GAAG,CAAHA,UAAAA,CAAAA,WAAAA,EAAAA,IAAAA,EAAAA,GAAAA;AACD;;;;WAGDC,wBAAe;AACb,UAAMD,GAAG,GAAG,KAAZ,IAAA;AACAA,MAAAA,GAAG,CAAHA,GAAAA,GAAU,KAAVA,SAAAA;AAEAE,MAAAA,MAAM,GAAGF,GAAG,CAAHA,UAAAA,KAAmBA,GAAG,CAA/BE,GAAAA;AACAC,MAAAA,GAAG,GAAHA,CAAAA;AACAC,MAAAA,MAAM,GAANA,CAAAA;AACAC,MAAAA,CAAC,GAADA,CAAAA;AACAC,MAAAA,CAAC,GAADA,CAAAA;AACAC,MAAAA,CAAC,GAADA,CAAAA;AAOA,UAAMC,KAAK,GAAX,EAAA;AACA,UAAMC,IAAI,GAAV,EAAA;;AAEA,aAAOT,GAAG,CAAHA,GAAAA,GAAP,MAAA,EAAyB;AACvB,YAAII,MAAM,IAAV,CAAA,EAAiB;AACfM,UAAAA,MAAM,GAAGV,GAAG,CAAZU,UAASV,EAATU;AACAP,UAAAA,GAAG,GAAGO,MAAM,GAAZP,GAAAA;AACAC,UAAAA,MAAM,GAAGM,MAAM,IAAfN,CAAAA;AACD;;AAEDA,QAAAA,MAAM;;AAEN,YAAID,GAAG,KAAHA,CAAAA,IAAaA,GAAG,KAApB,CAAA,EAA4B;AAC1BE,UAAAA,CAAC,IAAIL,GAAG,CAARK,WAAKL,EAALK;AACAC,UAAAA,CAAC,IAAIN,GAAG,CAARM,WAAKN,EAALM;;AAEA,cAAIH,GAAG,KAAP,CAAA,EAAe;AAEbK,YAAAA,KAAK,CAALA,IAAAA,CAAAA,CAAAA;AACD;;AACDC,UAAAA,IAAI,CAAJA,IAAAA,CAAAA,CAAAA,EAAAA,CAAAA;AACAF,UAAAA,CAAC,IAADA,CAAAA;AATF,SAAA,MAUO,IAAIJ,GAAG,KAAP,CAAA,EAAe;AAEpB,cAAII,CAAC,GAAL,CAAA,EAAW;AACT,gBAAMI,KAAK,GAAGH,KAAK,CAACA,KAAK,CAALA,MAAAA,GAApB,CAAmB,CAAnB;AACAC,YAAAA,IAAI,CAAJA,IAAAA,CAAUA,IAAI,CAAdA,KAAc,CAAdA,EAAuBA,IAAI,CAACE,KAAK,GAAjCF,CAA2B,CAA3BA;AACAF,YAAAA,CAAC,IAADA,CAAAA;AACD;AANI,SAAA,MAOA;AACL,gBAAM,IAAA,KAAA,CAAA,mBAAA,MAAA,CAAN,GAAM,CAAA,CAAN;AACD;AACF;;AAED,aAAO;AAACE,QAAAA,IAAD,EAACA,IAAD;AAAOD,QAAAA,KAAAA,EAAAA;AAAP,OAAP;AACD;;;WAEDI,8BAAoB,SAApBA,EAAgC;AAqB9B,UAAIC,IAAI,GAAG,KAAX,YAAW,EAAX;AAGAC,MAAAA,SAAS,CAACD,IAAI,CAAL,IAAA,EAATC,IAAS,CAATA;AAEA,UAAMC,WAAW,GAAjB,CAAA;;AAEA,cAAQ,KAAR,IAAA;AACE,aAAA,CAAA;AACE,eAAA,cAAA,CAAA,kBAAA;AACA,eAAA,cAAA,CAAA,mBAAA,IAA2CF,IAAI,CAAJA,KAAAA,CAA3C,MAAA;AACA;;AAEF,aAAA,CAAA;AACE,eAAA,cAAA,CAAA,iBAAA;AACA,eAAA,cAAA,CAAA,cAAA,IAAsCA,IAAI,CAAJA,KAAAA,CAAtC,MAAA;AACA,eAAA,cAAA,CAAA,kBAAA,IAA0CA,IAAI,CAAJA,IAAAA,CAAAA,MAAAA,GAA1C,WAAA;AACA;;AAEF,aAAA,CAAA;AACE,cAAMG,UAAU,GAAGnB,aAAa,CAAhC,IAAgC,CAAhC;AAIA,eAAA,cAAA,CAAA,oBAAA;AACA,eAAA,cAAA,CAAA,mBAAA,IAA2CmB,UAAU,CAAVA,KAAAA,CAA3C,MAAA;;AANF,qDAQsBA,UAAU,CAA9B,KARF;AAAA;;AAAA;AAQE,gEAAsC;AAAA,kBAAtC,KAAsC;AACpC,mBAAA,cAAA,CAAA,iBAAA,IAAyCR,KAAK,CAA9C,MAAA;AACD;AAVH;AAAA;AAAA;AAAA;AAAA;;AAWE,eAAA,cAAA,CAAA,qBAAA,IAA6CQ,UAAU,CAAVA,IAAAA,CAAAA,MAAAA,GAA7C,WAAA;AAGAH,UAAAA,IAAI,GAAJA,UAAAA;AACA;AA3BJ;;AA8BAA,MAAAA,IAAI,CAAJA,IAAAA,GAAYI,iBAAiB,CAAjBA,KAAAA,CAAwB,KAApCJ,IAAYI,CAAZJ;;AACA,UAAIA,IAAI,CAAJA,KAAAA,CAAAA,MAAAA,GAAJ,CAAA,EAA2B;AACzBA,QAAAA,IAAI,CAAJA,IAAAA,GAAAA,QAAAA,MAAAA,CAAoBA,IAAI,CAAxBA,IAAAA,CAAAA;AACD;;AAED,UAAMK,MAAM,GAAG;AACbC,QAAAA,IAAI,EADS,SAAA;AAEbC,QAAAA,QAAQ,EAFK,IAAA;AAGbC,QAAAA,UAAU,EAAE,KAAKA;AAHJ,OAAf;;AAMA,UAAI,KAAA,EAAA,KAAJ,IAAA,EAAsB;AACpBH,QAAAA,MAAM,CAANA,EAAAA,GAAY,KAAZA,EAAAA;AACD;;AAED,aAAA,MAAA;AACD;;;WAEDI,6BAAmB,OAAnBA,EAA6B;AAC3B,UAAI,OAAA,OAAA,KAAJ,UAAA,EAAmC;AACjC,eAAO,KAAA,oBAAA,CAAP,OAAO,CAAP;AACD;;AACD,UAAM,CAAN,GAAA,OAAA,CAAM,CAAN;AAAA,UAAM,CAAN,GAAA,OAAA,CAAM,CAAN;AAAA,UAAaC,CAAb,GAAA,OAAA,CAAaA,CAAb;AACA,UAAMC,IAAI,GAAG,KAAA,MAAA,GAAcC,IAAI,CAAJA,GAAAA,CAAAA,CAAAA,EAA3B,CAA2BA,CAA3B;AACA,UAAMC,EAAE,GAAG,KAAA,MAAA,GAAX,CAAA;AACA,UAAMC,EAAE,GAAG,KAAA,MAAA,GAAX,CAAA;;AAEA,eAAA,OAAA,CAAA,IAAA,EAAuB;AACrB,aAAK,IAAIC,CAAC,GAAL,CAAA,EAAWC,EAAE,GAAGpB,IAAI,CAAzB,MAAA,EAAkCmB,CAAC,GAAnC,EAAA,EAA0CA,CAAC,IAA3C,CAAA,EAAkD;AAChDnB,UAAAA,IAAI,CAAJA,CAAI,CAAJA,GAAW,CAACA,IAAI,CAAJA,CAAI,CAAJA,GAAD,EAAA,IAAD,GAAC,GAAD,IAAC,GAAXA,GAAAA;AACA,cAAMqB,EAAE,GAAG,MAAO,CAACrB,IAAI,CAACmB,CAAC,GAANnB,CAAI,CAAJA,GAAD,EAAA,IAAD,GAAC,GAAlB,IAAA;AACAA,UAAAA,IAAI,CAACmB,CAAC,GAANnB,CAAI,CAAJA,GAAe,MAAMgB,IAAI,CAAX,EAAC,GAAiBA,IAAI,CAAJA,IAAAA,CAAUA,IAAI,CAAJA,GAAAA,CAAUK,EAAE,GAAGL,IAAI,CAAV,EAACK,GAAtC,GAA4BL,CAAVA,CAAjB,GAAfhB,EAAAA;AACD;AACF;;AACD,aAAO,KAAA,oBAAA,CAAP,OAAO,CAAP;AACD;;;SAxKUX,eAAQ;AACjB,aAAO,CAAA,SAAA,EAAA,OAAA,EAAA,YAAA,EAAP,SAAO,CAAP;AACD;;;;;;SAHY,iB;;AAkLf,SAAA,aAAA,CAAA,IAAA,EAA6B;AAC3B,MAAMiC,GAAG,GAAGlB,IAAI,CAAJA,KAAAA,CAAZ,MAAA;;AAEA,MAAIkB,GAAG,IAAP,CAAA,EAAc;AACZ,WAAO;AACLtB,MAAAA,IAAI,EAAEI,IAAI,CADL,IAAA;AAELmB,MAAAA,KAAK,EAAE,CAAC,CAACC,oBAAoB,CAACpB,IAAI,CAF7B,IAEwB,CAArB,CAAD,CAFF;AAGLL,MAAAA,KAAK,EAAE,CAACK,IAAI,CAAL,KAAA;AAHF,KAAP;AAKD;;AAED,MAAMmB,KAAK,GAAX,EAAA;AACA,MAAME,QAAQ,GAAd,EAAA;AACA,MAAA,SAAA;AACA,MAAA,OAAA;AACA,MAAA,GAAA;AACA,MAAIC,MAAM,GAAV,CAAA;;AAEA,OAAK,IAAI5B,EAAC,GAAL,CAAA,EAAA,UAAA,EAAL,QAAA,EAAsCA,EAAC,GAAvC,GAAA,EAA+CA,EAA/C,EAAA,EAAoD;AAClD6B,IAAAA,UAAU,GAAGvB,IAAI,CAAJA,KAAAA,CAAAA,EAAAA,IAAbuB,MAAAA;AAEAC,IAAAA,QAAQ,GAAGxB,IAAI,CAAJA,KAAAA,CAAWN,EAAC,GAAZM,CAAAA,IAAAA,MAAAA,IAA8BA,IAAI,CAAJA,IAAAA,CAAzCwB,MAAAA;AACA,QAAMC,KAAK,GAAGzB,IAAI,CAAJA,IAAAA,CAAAA,KAAAA,CAAAA,UAAAA,EAAd,QAAcA,CAAd;AACA,QAAM0B,IAAI,GAAGN,oBAAoB,CAAjC,KAAiC,CAAjC;;AAEA,QAAIM,IAAI,KAAR,CAAA,EAAgB;AAGd,UAAMC,MAAM,GAAG3B,IAAI,CAAJA,IAAAA,CAAAA,KAAAA,CAAAA,CAAAA,EAAf,UAAeA,CAAf;AACA,UAAM4B,KAAK,GAAG5B,IAAI,CAAJA,IAAAA,CAAAA,KAAAA,CAAd,QAAcA,CAAd;AACAA,MAAAA,IAAI,CAAJA,IAAAA,GAAY2B,MAAM,CAANA,MAAAA,CAAZ3B,KAAY2B,CAAZ3B;AAIAsB,MAAAA,MAAM,IAAIE,QAAQ,GAAlBF,UAAAA;AAGA;AACD;;AAED,QAAIO,GAAG,KAAP,SAAA,EAAuBA,GAAG,GAAGH,IAAI,GAAVG,CAAAA;;AAEvB,QAAIA,GAAG,KAAKH,IAAI,GAAhB,CAAA,EAAsB;AACpB,UAAA,OAAA,EAAa;AACXP,QAAAA,KAAK,CAALA,IAAAA,CAAAA,SAAAA;AACAE,QAAAA,QAAQ,CAARA,IAAAA,CAAAA,OAAAA;AACD;;AACDS,MAAAA,OAAO,GAAG,CAAVA,UAAU,CAAVA;AACAC,MAAAA,SAAS,GAAG,CAAZA,IAAY,CAAZA;AANF,KAAA,MAOO;AAELA,MAAAA,SAAS,CAATA,IAAAA,CAAAA,IAAAA;AAEAD,MAAAA,OAAO,CAAPA,IAAAA,CAAAA,UAAAA;AACD;AACF;;AACD,MAAA,SAAA,EAAeX,KAAK,CAALA,IAAAA,CAAAA,SAAAA;AACf,MAAA,OAAA,EAAaE,QAAQ,CAARA,IAAAA,CAAAA,OAAAA;AAEb,SAAO;AAACF,IAAAA,KAAD,EAACA,KAAD;AAAQxB,IAAAA,KAAK,EAAb,QAAA;AAAyBC,IAAAA,IAAI,EAAEI,IAAI,CAACJ;AAApC,GAAP;AACD;;AAID,SAAA,WAAA,CAAA,GAAA,EAAA,OAAA,EAAA,GAAA,EAAwC;AACtC,MAAIoC,GAAG,KAAP,CAAA,EAAeC,OAAO,CAAPA,EAAAA,GAAa9C,GAAG,CAA/B,UAA4BA,EAAb8C,CAAf,KACK,IAAID,GAAG,KAAP,CAAA,EAAeE,OAAO,CAAA,GAAA,EAAtB,OAAsB,CAAPA,CAAf,KACA,IAAIF,GAAG,KAAP,CAAA,EAAeC,OAAO,CAAPA,IAAAA,GAAe9C,GAAG,CAAjC,UAA8BA,EAAf8C,CAAf,KACA,IAAID,GAAG,KAAP,CAAA,EAAeC,OAAO,CAAPA,SAAAA,GAAoB9C,GAAG,CAAvB8C,GAAAA;AACrB;;AAED,SAAA,OAAA,CAAA,GAAA,EAAA,OAAA,EAA+B;AAC7B,MAAME,GAAG,GAAGhD,GAAG,CAAHA,UAAAA,KAAmBA,GAAG,CAAlC,GAAA;;AAEA,SAAOA,GAAG,CAAHA,GAAAA,GAAP,GAAA,EAAsB;AACpB,QAAMiD,GAAG,GAAGH,OAAO,CAAPA,KAAAA,CAAc9C,GAAG,CAA7B,UAA0BA,EAAd8C,CAAZ;;AACA,QAAMI,KAAK,GAAGJ,OAAO,CAAPA,OAAAA,CAAgB9C,GAAG,CAAjC,UAA8BA,EAAhB8C,CAAd;;AACAA,IAAAA,OAAO,CAAPA,UAAAA,CAAAA,GAAAA,IAAAA,KAAAA;AACD;AACF","sourcesContent":["// This code is forked from https://github.com/mapbox/vector-tile-js under BSD 3-clause license.\n/* eslint-disable */\n\nimport {getPolygonSignedArea} from '@math.gl/polygon';\n\n// Reduce GC by reusing variables\nlet endPos, cmd, cmdLen, length, x, y, i;\n\nexport const TEST_EXPORTS = {\n  classifyRings\n};\n\nexport default class VectorTileFeature {\n  static get types() {\n    return ['Unknown', 'Point', 'LineString', 'Polygon'];\n  }\n\n  constructor(pbf, end, extent, keys, values, firstPassData) {\n    // Public\n    this.properties = {};\n    this.extent = extent;\n    this.type = 0;\n    this.id = null;\n\n    // Private\n    this._pbf = pbf;\n    this._geometry = -1;\n    this._keys = keys;\n    this._values = values;\n    this._firstPassData = firstPassData;\n\n    pbf.readFields(readFeature, this, end);\n  }\n\n  // eslint-disable-next-line complexity, max-statements\n  loadGeometry() {\n    const pbf = this._pbf;\n    pbf.pos = this._geometry;\n\n    endPos = pbf.readVarint() + pbf.pos;\n    cmd = 1;\n    length = 0;\n    x = 0;\n    y = 0;\n    i = 0;\n\n    // Note: I attempted to replace the `data` array with a\n    // Float32Array, but performance was worse, both using\n    // `set()` and direct index access. Also, we cannot\n    // know how large the buffer should be, so it would\n    // increase memory usage\n    const lines = []; // Indices where lines start\n    const data = []; // Flat array of coordinate data\n\n    while (pbf.pos < endPos) {\n      if (length <= 0) {\n        cmdLen = pbf.readVarint();\n        cmd = cmdLen & 0x7;\n        length = cmdLen >> 3;\n      }\n\n      length--;\n\n      if (cmd === 1 || cmd === 2) {\n        x += pbf.readSVarint();\n        y += pbf.readSVarint();\n\n        if (cmd === 1) {\n          // New line\n          lines.push(i);\n        }\n        data.push(x, y);\n        i += 2;\n      } else if (cmd === 7) {\n        // Workaround for https://github.com/mapbox/mapnik-vector-tile/issues/90\n        if (i > 0) {\n          const start = lines[lines.length - 1]; // start index of polygon\n          data.push(data[start], data[start + 1]); // closePolygon\n          i += 2;\n        }\n      } else {\n        throw new Error(`unknown command ${cmd}`);\n      }\n    }\n\n    return {data, lines};\n  }\n\n  _toBinaryCoordinates(transform) {\n    // Expands the protobuf data to an intermediate `lines`\n    // data format, which maps closely to the binary data buffers.\n    // It is similar to GeoJSON, but rather than storing the coordinates\n    // in multidimensional arrays, we have a 1D `data` with all the\n    // coordinates, and then index into this using the `lines`\n    // parameter, e.g.\n    //\n    // geometry: {\n    //   type: 'Point', data: [1,2], lines: [0]\n    // }\n    // geometry: {\n    //   type: 'LineString', data: [1,2,3,4,...], lines: [0]\n    // }\n    // geometry: {\n    //   type: 'Polygon', data: [1,2,3,4,...], lines: [[0, 2]]\n    // }\n    // Thus the lines member lets us look up the relevant range\n    // from the data array.\n    // The Multi* versions of the above types share the same data\n    // structure, just with multiple elements in the lines array\n    let geom = this.loadGeometry();\n\n    // Apply the supplied transformation to data\n    transform(geom.data, this);\n\n    const coordLength = 2;\n\n    switch (this.type) {\n      case 1: // Point\n        this._firstPassData.pointFeaturesCount++;\n        this._firstPassData.pointPositionsCount += geom.lines.length;\n        break;\n\n      case 2: // LineString\n        this._firstPassData.lineFeaturesCount++;\n        this._firstPassData.linePathsCount += geom.lines.length;\n        this._firstPassData.linePositionsCount += geom.data.length / coordLength;\n        break;\n\n      case 3: // Polygon\n        const classified = classifyRings(geom);\n\n        // Unlike Point & LineString geom.lines is a 2D array, thanks\n        // to the classifyRings method\n        this._firstPassData.polygonFeaturesCount++;\n        this._firstPassData.polygonObjectsCount += classified.lines.length;\n\n        for (const lines of classified.lines) {\n          this._firstPassData.polygonRingsCount += lines.length;\n        }\n        this._firstPassData.polygonPositionsCount += classified.data.length / coordLength;\n\n        // @ts-ignore\n        geom = classified;\n        break;\n    }\n\n    geom.type = VectorTileFeature.types[this.type];\n    if (geom.lines.length > 1) {\n      geom.type = `Multi${geom.type}`;\n    }\n\n    const result = {\n      type: 'Feature',\n      geometry: geom,\n      properties: this.properties\n    };\n\n    if (this.id !== null) {\n      result.id = this.id;\n    }\n\n    return result;\n  }\n\n  toBinaryCoordinates(options) {\n    if (typeof options === 'function') {\n      return this._toBinaryCoordinates(options);\n    }\n    const {x, y, z} = options;\n    const size = this.extent * Math.pow(2, z);\n    const x0 = this.extent * x;\n    const y0 = this.extent * y;\n\n    function project(data) {\n      for (let j = 0, jl = data.length; j < jl; j += 2) {\n        data[j] = ((data[j] + x0) * 360) / size - 180;\n        const y2 = 180 - ((data[j + 1] + y0) * 360) / size;\n        data[j + 1] = (360 / Math.PI) * Math.atan(Math.exp((y2 * Math.PI) / 180)) - 90;\n      }\n    }\n    return this._toBinaryCoordinates(project);\n  }\n}\n\n/**\n * Classifies an array of rings into polygons with outer rings and holes\n * The function also detects holes which have zero area and\n * removes them. In doing so it modifies the input\n * `geom.data` array to remove the unneeded data\n */\nfunction classifyRings(geom) {\n  const len = geom.lines.length;\n\n  if (len <= 1) {\n    return {\n      data: geom.data,\n      areas: [[getPolygonSignedArea(geom.data)]],\n      lines: [geom.lines]\n    };\n  }\n\n  const areas = [];\n  const polygons = [];\n  let ringAreas;\n  let polygon;\n  let ccw;\n  let offset = 0;\n\n  for (let i = 0, startIndex, endIndex; i < len; i++) {\n    startIndex = geom.lines[i] - offset;\n\n    endIndex = geom.lines[i + 1] - offset || geom.data.length;\n    const shape = geom.data.slice(startIndex, endIndex);\n    const area = getPolygonSignedArea(shape);\n\n    if (area === 0) {\n      // This polygon has no area, so remove it from the shape\n      // Remove the section from the data array\n      const before = geom.data.slice(0, startIndex);\n      const after = geom.data.slice(endIndex);\n      geom.data = before.concat(after);\n\n      // Need to offset any remaining indices as we have\n      // modified the data buffer\n      offset += endIndex - startIndex;\n\n      // Do not add this index to the output and process next shape\n      continue;\n    }\n\n    if (ccw === undefined) ccw = area < 0;\n\n    if (ccw === area < 0) {\n      if (polygon) {\n        areas.push(ringAreas);\n        polygons.push(polygon);\n      }\n      polygon = [startIndex];\n      ringAreas = [area];\n    } else {\n      // @ts-ignore\n      ringAreas.push(area);\n      // @ts-ignore\n      polygon.push(startIndex);\n    }\n  }\n  if (ringAreas) areas.push(ringAreas);\n  if (polygon) polygons.push(polygon);\n\n  return {areas, lines: polygons, data: geom.data};\n}\n\n// All code below is unchanged from the original Mapbox implemenation\n\nfunction readFeature(tag, feature, pbf) {\n  if (tag === 1) feature.id = pbf.readVarint();\n  else if (tag === 2) readTag(pbf, feature);\n  else if (tag === 3) feature.type = pbf.readVarint();\n  else if (tag === 4) feature._geometry = pbf.pos;\n}\n\nfunction readTag(pbf, feature) {\n  const end = pbf.readVarint() + pbf.pos;\n\n  while (pbf.pos < end) {\n    const key = feature._keys[pbf.readVarint()];\n    const value = feature._values[pbf.readVarint()];\n    feature.properties[key] = value;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}