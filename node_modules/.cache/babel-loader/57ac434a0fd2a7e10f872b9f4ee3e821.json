{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/ESG-dell/Documents/Dev/Hachathon-miasta/PTA-frontend/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"C:/Users/ESG-dell/Documents/Dev/Hachathon-miasta/PTA-frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport * as KHR_draco_mesh_compression from './KHR_draco_mesh_compression';\nimport * as KHR_materials_unlit from './KHR_materials_unlit';\nimport * as KHR_lights_punctual from './KHR_lights_punctual';\nimport * as KHR_techniques_webgl from './KHR_techniques_webgl';\nexport var EXTENSIONS = {\n  KHR_draco_mesh_compression: KHR_draco_mesh_compression,\n  KHR_materials_unlit: KHR_materials_unlit,\n  KHR_lights_punctual: KHR_lights_punctual,\n  KHR_techniques_webgl: KHR_techniques_webgl\n};\nexport function decodeExtensions(_x) {\n  return _decodeExtensions.apply(this, arguments);\n}\n\nfunction _decodeExtensions() {\n  _decodeExtensions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(gltf) {\n    var options,\n        context,\n        extensionName,\n        _options$gltf,\n        excludes,\n        exclude,\n        extension,\n        _args = arguments;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n            context = _args.length > 2 ? _args[2] : undefined;\n            _context.t0 = _regeneratorRuntime.keys(EXTENSIONS);\n\n          case 3:\n            if ((_context.t1 = _context.t0()).done) {\n              _context.next = 13;\n              break;\n            }\n\n            extensionName = _context.t1.value;\n            excludes = (options === null || options === void 0 ? void 0 : (_options$gltf = options.gltf) === null || _options$gltf === void 0 ? void 0 : _options$gltf.excludeExtensions) || {};\n            exclude = extensionName in excludes && !excludes[extensionName];\n\n            if (exclude) {\n              _context.next = 11;\n              break;\n            }\n\n            extension = EXTENSIONS[extensionName];\n            _context.next = 11;\n            return extension.decode(gltf, options, context);\n\n          case 11:\n            _context.next = 3;\n            break;\n\n          case 13:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _decodeExtensions.apply(this, arguments);\n}","map":{"version":3,"sources":["../../../../src/lib/extensions/gltf-extensions.ts"],"names":["EXTENSIONS","KHR_draco_mesh_compression","KHR_materials_unlit","KHR_lights_punctual","KHR_techniques_webgl","options","excludes","exclude","extensionName","extension"],"mappings":";;AAQA,OAAO,KAAP,0BAAA,MAAA,8BAAA;AACA,OAAO,KAAP,mBAAA,MAAA,uBAAA;AACA,OAAO,KAAP,mBAAA,MAAA,uBAAA;AACA,OAAO,KAAP,oBAAA,MAAA,wBAAA;AAaA,OAAO,IAAMA,UAA0D,GAAG;AAMxEC,EAAAA,0BANwE,EAMxEA,0BANwE;AAOxEC,EAAAA,mBAPwE,EAOxEA,mBAPwE;AAQxEC,EAAAA,mBARwE,EAQxEA,mBARwE;AASxEC,EAAAA,oBAAAA,EAAAA;AATwE,CAAnE;AAYP,gBAAO,gBAAP;AAAA;AAAA;;;+EAAO,iBAAA,IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAsCC,YAAAA,OAAtC,2DAAA,EAAA;AAAA,YAAA,OAAA;AAAA,mDACL,UADK;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACL,YAAA,aADK;AAEGC,YAAAA,QAFH,GAEc,CAAA,OAAO,KAAP,IAAA,IAAA,OAAO,KAAA,KAAP,CAAA,GAAA,KAAA,CAAA,GAAA,CAAA,aAAA,GAAA,OAAO,CAAP,IAAA,MAAA,IAAA,IAAA,aAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,aAAA,CAAA,iBAAA,KAAjB,EAFG;AAGGC,YAAAA,OAHH,GAGaC,aAAa,IAAbA,QAAAA,IAA6B,CAACF,QAAQ,CAAtD,aAAsD,CAHnD;;AAAA,gBAIH,OAJG;AAAA;AAAA;AAAA;;AAKKG,YAAAA,SALL,GAKiBT,UAAU,CAA5B,aAA4B,CAL3B;AAAA;AAAA,mBAQKS,SAAS,CAATA,MAAAA,CAAAA,IAAAA,EAAAA,OAAAA,EAAN,OAAMA,CARL;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G","sourcesContent":["/* eslint-disable camelcase */\nimport {GLTF} from '../types/gltf-types';\nimport type {GLTFLoaderOptions} from '../../gltf-loader';\n\n// GLTF 1.0 extensions (read only)\n// import * as KHR_binary_gltf from './KHR_draco_mesh_compression';\n\n// GLTF 2.0 extensions (read/write)\nimport * as KHR_draco_mesh_compression from './KHR_draco_mesh_compression';\nimport * as KHR_materials_unlit from './KHR_materials_unlit';\nimport * as KHR_lights_punctual from './KHR_lights_punctual';\nimport * as KHR_techniques_webgl from './KHR_techniques_webgl';\n\ntype GLTFExtensionPlugin = {\n  decode: (gltfData: {json: GLTF}, options: GLTFLoaderOptions, context) => Promise<void>;\n\n  encode: (gltfData: {json: GLTF}, options: GLTFLoaderOptions) => void;\n};\n\n/**\n * List of extensions processed by the GLTFLoader\n * Note that may extensions can only be handled on the rendering stage and are left out here\n * These are just extensions that can be handled fully or partially during loading.\n */\nexport const EXTENSIONS: {[extensionName: string]: GLTFExtensionPlugin} = {\n  // 1.0\n  // KHR_binary_gltf is handled separately - must be processed before other parsing starts\n  // KHR_binary_gltf,\n\n  // 2.0\n  KHR_draco_mesh_compression,\n  KHR_materials_unlit,\n  KHR_lights_punctual,\n  KHR_techniques_webgl\n};\n\nexport async function decodeExtensions(gltf, options: GLTFLoaderOptions = {}, context?) {\n  for (const extensionName in EXTENSIONS) {\n    const excludes = options?.gltf?.excludeExtensions || {};\n    const exclude = extensionName in excludes && !excludes[extensionName];\n    if (!exclude) {\n      const extension = EXTENSIONS[extensionName];\n      // Note: We decode async extensions sequentially, this might not be necessary\n      // Currently we only have Draco, but when we add Basis we may revisit\n      await extension.decode(gltf, options, context);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}