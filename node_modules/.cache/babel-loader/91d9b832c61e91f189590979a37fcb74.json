{"ast":null,"code":"import _slicedToArray from \"C:/Users/ESG-dell/Documents/Dev/Hachathon-miasta/PTA-frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport { toRadians } from '@math.gl/core';\nvar WGS84_RADIUS_X = 6378137.0;\nvar qualityFactor = Math.PI / 2;\nexport function lodJudge(tile, frameState) {\n  var viewport = frameState.viewport;\n  var metersPerPixel = viewport.metersPerPixel;\n  var mbsLat = tile.header.mbs[1];\n  var mbsLon = tile.header.mbs[0];\n  var mbsZ = tile.header.mbs[2];\n  var mbsR = tile.header.mbs[3];\n  var height = viewport.height,\n      width = viewport.width,\n      latitude = viewport.latitude,\n      longitude = viewport.longitude;\n  var viewportCenter = [longitude, latitude];\n  var mbsCenter = [mbsLon, mbsLat, mbsZ];\n  var mbsLatProjected = [longitude, mbsLat];\n  var mbsLonProjected = [mbsLon, latitude];\n  var diagonalInMeters = Math.sqrt(height * height + width * width) * metersPerPixel[0];\n  var distanceInMeters = getDistanceFromLatLon(viewportCenter, mbsCenter);\n  var visibleHeight = height * 0.5 + mbsR / WGS84_RADIUS_X;\n  var visibleWidth = width * 0.5 + mbsR / WGS84_RADIUS_X;\n\n  if (distanceInMeters > diagonalInMeters + mbsR / WGS84_RADIUS_X) {\n    return 'OUT';\n  }\n\n  if (getDistanceFromLatLon(viewportCenter, mbsLatProjected) > visibleHeight) {\n    return 'OUT';\n  }\n\n  if (getDistanceFromLatLon(viewportCenter, mbsLonProjected) > visibleWidth) {\n    return 'OUT';\n  }\n\n  if (tile.lodMetricValue === 0) {\n    return 'DIG';\n  }\n\n  var screenSize = getI3ScreenSize(tile, frameState);\n  screenSize *= qualityFactor;\n\n  if (screenSize < 0.5) {\n    return 'OUT';\n  }\n\n  if (!tile.header.children || screenSize <= tile.lodMetricValue) {\n    return 'DRAW';\n  } else if (tile.header.children) {\n    return 'DIG';\n  }\n\n  return 'OUT';\n}\n\nfunction projectVertexToSphere(_ref) {\n  var _ref2 = _slicedToArray(_ref, 3),\n      x = _ref2[0],\n      y = _ref2[1],\n      z = _ref2[2];\n\n  var azim = toRadians(x);\n  var incl = toRadians(y);\n  var radius = 1.0 + z / WGS84_RADIUS_X;\n  var radCosInc = radius * Math.cos(incl);\n  x = radCosInc * Math.cos(azim);\n  y = radCosInc * Math.sin(azim);\n  z = radius * Math.sin(incl);\n  return [x, y, z];\n}\n\nfunction getDistanceFromLatLon(observer, center) {\n  var _observer = _slicedToArray(observer, 3),\n      observerLon = _observer[0],\n      observerLat = _observer[1],\n      _observer$ = _observer[2],\n      observerZ = _observer$ === void 0 ? 0.0 : _observer$;\n\n  var _center = _slicedToArray(center, 3),\n      centerLon = _center[0],\n      centerLat = _center[1],\n      _center$ = _center[2],\n      centerZ = _center$ === void 0 ? 0.0 : _center$;\n\n  var projectedCenter = projectVertexToSphere([centerLon, centerLat, centerZ]);\n  var projectedObserver = projectVertexToSphere([observerLon, observerLat, observerZ]);\n  var dx = projectedObserver[0] - projectedCenter[0];\n  var dy = projectedObserver[1] - projectedCenter[1];\n  var dz = projectedObserver[2] - projectedCenter[2];\n  return dx * dx + dy * dy + dz * dz;\n}\n\nexport function getI3ScreenSize(tile, frameState) {\n  var viewport = frameState.viewport;\n  var mbsLat = tile.header.mbs[1];\n  var mbsLon = tile.header.mbs[0];\n  var mbsZ = tile.header.mbs[2];\n  var mbsR = tile.header.mbs[3];\n  var mbsCenter = [mbsLon, mbsLat, mbsZ];\n  var cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);\n  var dSquared = getDistanceFromLatLon(cameraPositionCartographic, mbsCenter);\n  var mbsRNormalized = mbsR / WGS84_RADIUS_X;\n  var d = dSquared - mbsRNormalized * mbsRNormalized;\n  var fltMax = 3.4028235e38;\n\n  if (d <= 0.0) {\n    return 0.5 * fltMax;\n  }\n\n  var screenSizeFactor = getTanOfHalfVFAngle(frameState) * mbsRNormalized / Math.sqrt(d) * 300;\n  return screenSizeFactor;\n}\n\nfunction getTanOfHalfVFAngle(frameState) {\n  var projectionMatrix = frameState.viewport.projectionMatrix;\n  var t = projectionMatrix[5];\n  return t;\n}","map":{"version":3,"sources":["../../../../src/tileset/helpers/i3s-lod.ts"],"names":["WGS84_RADIUS_X","qualityFactor","Math","viewport","frameState","metersPerPixel","mbsLat","tile","mbsLon","mbsZ","mbsR","longitude","viewportCenter","mbsCenter","mbsLatProjected","mbsLonProjected","diagonalInMeters","height","width","distanceInMeters","getDistanceFromLatLon","visibleHeight","visibleWidth","screenSize","getI3ScreenSize","azim","toRadians","incl","radius","z","radCosInc","x","y","observerZ","centerZ","projectedCenter","projectVertexToSphere","projectedObserver","dx","dy","dz","cameraPositionCartographic","dSquared","mbsRNormalized","d","fltMax","screenSizeFactor","getTanOfHalfVFAngle","projectionMatrix","t"],"mappings":"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","sourcesContent":["import {toRadians} from '@math.gl/core';\n\nconst WGS84_RADIUS_X = 6378137.0;\n// use this to bias the lod switching  (1+ results in increasing the LOD quality)\nconst qualityFactor = Math.PI / 2; // empirical derived bias factor\n/* eslint-disable max-statements */\nexport function lodJudge(tile, frameState) {\n  const viewport = frameState.viewport;\n  const metersPerPixel = viewport.metersPerPixel;\n\n  const mbsLat = tile.header.mbs[1];\n  const mbsLon = tile.header.mbs[0];\n  const mbsZ = tile.header.mbs[2];\n  const mbsR = tile.header.mbs[3];\n\n  const {height, width, latitude, longitude} = viewport;\n\n  const viewportCenter = [longitude, latitude];\n  const mbsCenter = [mbsLon, mbsLat, mbsZ];\n  const mbsLatProjected = [longitude, mbsLat];\n  const mbsLonProjected = [mbsLon, latitude];\n\n  const diagonalInMeters = Math.sqrt(height * height + width * width) * metersPerPixel[0];\n  const distanceInMeters = getDistanceFromLatLon(viewportCenter, mbsCenter);\n\n  const visibleHeight = height * 0.5 + mbsR / WGS84_RADIUS_X;\n  const visibleWidth = width * 0.5 + mbsR / WGS84_RADIUS_X;\n\n  if (distanceInMeters > diagonalInMeters + mbsR / WGS84_RADIUS_X) {\n    return 'OUT';\n  }\n  if (getDistanceFromLatLon(viewportCenter, mbsLatProjected) > visibleHeight) {\n    return 'OUT';\n  }\n  if (getDistanceFromLatLon(viewportCenter, mbsLonProjected) > visibleWidth) {\n    return 'OUT';\n  }\n\n  if (tile.lodMetricValue === 0) {\n    return 'DIG';\n  }\n\n  // For the maxScreenThreshold error metric, maxError means that you should replace the node with it's children\n  // as soon as the nodes bounding sphere has a screen radius larger than maxError pixels.\n  // In this sense a value of 0 means you should always load it's children,\n  // or if it's a leaf node, you should always display it.\n  let screenSize = getI3ScreenSize(tile, frameState); // in pixels\n  screenSize *= qualityFactor;\n  if (screenSize < 0.5) {\n    return 'OUT';\n  }\n  if (!tile.header.children || screenSize <= tile.lodMetricValue) {\n    return 'DRAW';\n  } else if (tile.header.children) {\n    return 'DIG';\n  }\n  return 'OUT';\n}\n\n/* eslint-enable max-statements */\n\nfunction projectVertexToSphere([x, y, z]) {\n  const azim = toRadians(x);\n  const incl = toRadians(y);\n  const radius = 1.0 + z / WGS84_RADIUS_X;\n  const radCosInc = radius * Math.cos(incl);\n  x = radCosInc * Math.cos(azim);\n  y = radCosInc * Math.sin(azim);\n  z = radius * Math.sin(incl);\n  return [x, y, z];\n}\n\nfunction getDistanceFromLatLon(observer: number[], center: number[]) {\n  const [observerLon, observerLat, observerZ = 0.0] = observer;\n  const [centerLon, centerLat, centerZ = 0.0] = center;\n\n  const projectedCenter = projectVertexToSphere([centerLon, centerLat, centerZ]);\n  const projectedObserver = projectVertexToSphere([observerLon, observerLat, observerZ]);\n  const dx = projectedObserver[0] - projectedCenter[0];\n  const dy = projectedObserver[1] - projectedCenter[1];\n  const dz = projectedObserver[2] - projectedCenter[2];\n  return dx * dx + dy * dy + dz * dz;\n}\n\nexport function getI3ScreenSize(tile, frameState) {\n  const viewport = frameState.viewport;\n  const mbsLat = tile.header.mbs[1];\n  const mbsLon = tile.header.mbs[0];\n  const mbsZ = tile.header.mbs[2];\n  const mbsR = tile.header.mbs[3];\n\n  const mbsCenter = [mbsLon, mbsLat, mbsZ];\n  const cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);\n  const dSquared = getDistanceFromLatLon(cameraPositionCartographic, mbsCenter);\n  const mbsRNormalized = mbsR / WGS84_RADIUS_X;\n  const d = dSquared - mbsRNormalized * mbsRNormalized;\n  const fltMax = 3.4028235e38; // convert from 0x7f7fffff which is the maximum\n  if (d <= 0.0) {\n    return 0.5 * fltMax;\n  }\n  // https://stackoverflow.com/questions/21648630/radius-of-projected-sphere-in-screen-space\n  // There is a formula there to calculate projected radius:\n  // return 1.0 / Math.tan(fov) * r / Math.sqrt(d * d - r * r); // Right\n  // Hack: 300 is a Magic number to get the correct LoD. Possibly, d and r are calculated in a wrong way.\n  const screenSizeFactor =\n    ((getTanOfHalfVFAngle(frameState) * mbsRNormalized) / Math.sqrt(d)) * 300;\n  return screenSizeFactor;\n}\n\nfunction getTanOfHalfVFAngle(frameState) {\n  const {projectionMatrix} = frameState.viewport;\n  const t = projectionMatrix[5];\n  return t;\n}\n"]},"metadata":{},"sourceType":"module"}