{"ast":null,"code":"import _classCallCheck from \"C:/Users/ESG-dell/Documents/Dev/Hachathon-miasta/PTA-frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/Users/ESG-dell/Documents/Dev/Hachathon-miasta/PTA-frontend/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nvar LRUCache = /*#__PURE__*/function () {\n  function LRUCache() {\n    var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 5;\n\n    _classCallCheck(this, LRUCache);\n\n    this.limit = limit;\n    this.clear();\n  }\n\n  _createClass(LRUCache, [{\n    key: \"clear\",\n    value: function clear() {\n      this._cache = {};\n      this._order = [];\n    }\n  }, {\n    key: \"get\",\n    value: function get(key) {\n      var value = this._cache[key];\n\n      if (value) {\n        this._deleteOrder(key);\n\n        this._appendOrder(key);\n      }\n\n      return value;\n    }\n  }, {\n    key: \"set\",\n    value: function set(key, value) {\n      if (!this._cache[key]) {\n        if (Object.keys(this._cache).length === this.limit) {\n          this.delete(this._order[0]);\n        }\n\n        this._cache[key] = value;\n\n        this._appendOrder(key);\n      } else {\n        this.delete(key);\n        this._cache[key] = value;\n\n        this._appendOrder(key);\n      }\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(key) {\n      var value = this._cache[key];\n\n      if (value) {\n        this._deleteCache(key);\n\n        this._deleteOrder(key);\n      }\n    }\n  }, {\n    key: \"_deleteCache\",\n    value: function _deleteCache(key) {\n      delete this._cache[key];\n    }\n  }, {\n    key: \"_deleteOrder\",\n    value: function _deleteOrder(key) {\n      var index = this._order.findIndex(function (o) {\n        return o === key;\n      });\n\n      if (index >= 0) {\n        this._order.splice(index, 1);\n      }\n    }\n  }, {\n    key: \"_appendOrder\",\n    value: function _appendOrder(key) {\n      this._order.push(key);\n    }\n  }]);\n\n  return LRUCache;\n}();\n\nexport { LRUCache as default };","map":{"version":3,"sources":["../../../src/text-layer/lru-cache.js"],"names":["constructor","limit","clear","get","value","set","Object","delete","_deleteCache","_deleteOrder","index","o","_appendOrder"],"mappings":";;;IAOe,Q;AACbA,sBAAuB;AAAA,QAAXC,KAAW,uEAAZ,CAAY;;AAAA;;AACrB,SAAA,KAAA,GAAA,KAAA;AAEA,SAAA,KAAA;AACD;;;;WAEDC,iBAAQ;AACN,WAAA,MAAA,GAAA,EAAA;AAEA,WAAA,MAAA,GAAA,EAAA;AACD;;;WAEDC,aAAG,GAAHA,EAAS;AACP,UAAMC,KAAK,GAAG,KAAA,MAAA,CAAd,GAAc,CAAd;;AACA,UAAA,KAAA,EAAW;AAET,aAAA,YAAA,CAAA,GAAA;;AACA,aAAA,YAAA,CAAA,GAAA;AACD;;AACD,aAAA,KAAA;AACD;;;WAEDC,aAAG,GAAHA,EAAG,KAAHA,EAAgB;AACd,UAAI,CAAC,KAAA,MAAA,CAAL,GAAK,CAAL,EAAuB;AAErB,YAAIC,MAAM,CAANA,IAAAA,CAAY,KAAZA,MAAAA,EAAAA,MAAAA,KAAoC,KAAxC,KAAA,EAAoD;AAClD,eAAA,MAAA,CAAY,KAAA,MAAA,CAAZ,CAAY,CAAZ;AACD;;AAED,aAAA,MAAA,CAAA,GAAA,IAAA,KAAA;;AACA,aAAA,YAAA,CAAA,GAAA;AAPF,OAAA,MAQO;AAEL,aAAA,MAAA,CAAA,GAAA;AAEA,aAAA,MAAA,CAAA,GAAA,IAAA,KAAA;;AACA,aAAA,YAAA,CAAA,GAAA;AACD;AACF;;;WAEDC,iBAAM,GAANA,EAAY;AACV,UAAMH,KAAK,GAAG,KAAA,MAAA,CAAd,GAAc,CAAd;;AACA,UAAA,KAAA,EAAW;AACT,aAAA,YAAA,CAAA,GAAA;;AACA,aAAA,YAAA,CAAA,GAAA;AACD;AACF;;;WAEDI,sBAAY,GAAZA,EAAkB;AAChB,aAAO,KAAA,MAAA,CAAP,GAAO,CAAP;AACD;;;WAEDC,sBAAY,GAAZA,EAAkB;AAChB,UAAMC,KAAK,GAAG,KAAA,MAAA,CAAA,SAAA,CAAsBC,UAAAA,CAAC;AAAA,eAAIA,CAAC,KAA1C,GAAqC;AAAA,OAAvB,CAAd;;AACA,UAAID,KAAK,IAAT,CAAA,EAAgB;AACd,aAAA,MAAA,CAAA,MAAA,CAAA,KAAA,EAAA,CAAA;AACD;AACF;;;WAEDE,sBAAY,GAAZA,EAAkB;AAChB,WAAA,MAAA,CAAA,IAAA,CAAA,GAAA;AACD;;;;;;SA9DY,Q","sourcesContent":["/**\n * LRU Cache class with limit\n *\n * Update order for each get/set operation\n * Delete oldest when reach given limit\n */\n\nexport default class LRUCache {\n  constructor(limit = 5) {\n    this.limit = limit;\n\n    this.clear();\n  }\n\n  clear() {\n    this._cache = {};\n    // access/update order, first item is oldest, last item is newest\n    this._order = [];\n  }\n\n  get(key) {\n    const value = this._cache[key];\n    if (value) {\n      // update order\n      this._deleteOrder(key);\n      this._appendOrder(key);\n    }\n    return value;\n  }\n\n  set(key, value) {\n    if (!this._cache[key]) {\n      // if reach limit, delete the oldest\n      if (Object.keys(this._cache).length === this.limit) {\n        this.delete(this._order[0]);\n      }\n\n      this._cache[key] = value;\n      this._appendOrder(key);\n    } else {\n      // if found in cache, delete the old one, insert new one to the first of list\n      this.delete(key);\n\n      this._cache[key] = value;\n      this._appendOrder(key);\n    }\n  }\n\n  delete(key) {\n    const value = this._cache[key];\n    if (value) {\n      this._deleteCache(key);\n      this._deleteOrder(key);\n    }\n  }\n\n  _deleteCache(key) {\n    delete this._cache[key];\n  }\n\n  _deleteOrder(key) {\n    const index = this._order.findIndex(o => o === key);\n    if (index >= 0) {\n      this._order.splice(index, 1);\n    }\n  }\n\n  _appendOrder(key) {\n    this._order.push(key);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}