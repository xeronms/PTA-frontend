{"ast":null,"code":"import { Vector3 } from '@math.gl/core';\nvar WGS84_RADIUS_X = 6378137.0;\nvar WGS84_RADIUS_Y = 6378137.0;\nvar WGS84_RADIUS_Z = 6356752.3142451793;\nvar scratchVector = new Vector3();\nexport function getZoomFromBoundingVolume(boundingVolume) {\n  var halfAxes = boundingVolume.halfAxes,\n      radius = boundingVolume.radius,\n      width = boundingVolume.width,\n      height = boundingVolume.height;\n\n  if (halfAxes) {\n    var obbSize = getObbSize(halfAxes);\n    return Math.log2(WGS84_RADIUS_Z / obbSize);\n  } else if (radius) {\n    return Math.log2(WGS84_RADIUS_Z / radius);\n  } else if (height && width) {\n    var zoomX = Math.log2(WGS84_RADIUS_X / width);\n    var zoomY = Math.log2(WGS84_RADIUS_Y / height);\n    return (zoomX + zoomY) / 2;\n  }\n\n  return 1;\n}\n\nfunction getObbSize(halfAxes) {\n  halfAxes.getColumn(0, scratchVector);\n  var axeY = halfAxes.getColumn(1);\n  var axeZ = halfAxes.getColumn(2);\n  var farthestVertex = scratchVector.add(axeY).add(axeZ);\n  var size = farthestVertex.len();\n  return size;\n}","map":{"version":3,"sources":["../../../../src/tileset/helpers/zoom.ts"],"names":["WGS84_RADIUS_X","WGS84_RADIUS_Y","WGS84_RADIUS_Z","scratchVector","height","obbSize","getObbSize","Math","zoomX","zoomY","halfAxes","axeY","axeZ","farthestVertex","size"],"mappings":"AAAA,SAAA,OAAA,QAAA,eAAA;AAEA,IAAMA,cAAc,GAApB,SAAA;AACA,IAAMC,cAAc,GAApB,SAAA;AACA,IAAMC,cAAc,GAApB,kBAAA;AAEA,IAAMC,aAAa,GAAG,IAAtB,OAAsB,EAAtB;AAOA,OAAO,SAAA,yBAAA,CAAA,cAAA,EAAmD;AACxD,MAAM,QAAN,GAAA,cAAA,CAAM,QAAN;AAAA,MAAM,MAAN,GAAA,cAAA,CAAM,MAAN;AAAA,MAAM,KAAN,GAAA,cAAA,CAAM,KAAN;AAAA,MAAgCC,MAAhC,GAAA,cAAA,CAAgCA,MAAhC;;AAEA,MAAA,QAAA,EAAc;AAEZ,QAAMC,OAAO,GAAGC,UAAU,CAA1B,QAA0B,CAA1B;AAEA,WAAOC,IAAI,CAAJA,IAAAA,CAAUL,cAAc,GAA/B,OAAOK,CAAP;AAJF,GAAA,MAKO,IAAA,MAAA,EAAY;AAEjB,WAAOA,IAAI,CAAJA,IAAAA,CAAUL,cAAc,GAA/B,MAAOK,CAAP;AAFK,GAAA,MAGA,IAAIH,MAAM,IAAV,KAAA,EAAqB;AAE1B,QAAMI,KAAK,GAAGD,IAAI,CAAJA,IAAAA,CAAUP,cAAc,GAAtC,KAAcO,CAAd;AACA,QAAME,KAAK,GAAGF,IAAI,CAAJA,IAAAA,CAAUN,cAAc,GAAtC,MAAcM,CAAd;AAEA,WAAO,CAACC,KAAK,GAAN,KAAA,IAAP,CAAA;AACD;;AAED,SAAA,CAAA;AACD;;AAED,SAAA,UAAA,CAAA,QAAA,EAA8B;AAC5BE,EAAAA,QAAQ,CAARA,SAAAA,CAAAA,CAAAA,EAAAA,aAAAA;AACA,MAAMC,IAAI,GAAGD,QAAQ,CAARA,SAAAA,CAAb,CAAaA,CAAb;AACA,MAAME,IAAI,GAAGF,QAAQ,CAARA,SAAAA,CAAb,CAAaA,CAAb;AACA,MAAMG,cAAc,GAAGV,aAAa,CAAbA,GAAAA,CAAAA,IAAAA,EAAAA,GAAAA,CAAvB,IAAuBA,CAAvB;AACA,MAAMW,IAAI,GAAGD,cAAc,CAA3B,GAAaA,EAAb;AACA,SAAA,IAAA;AACD","sourcesContent":["import {Vector3} from '@math.gl/core';\n\nconst WGS84_RADIUS_X = 6378137.0;\nconst WGS84_RADIUS_Y = 6378137.0;\nconst WGS84_RADIUS_Z = 6356752.3142451793;\n\nconst scratchVector = new Vector3();\n\n/**\n * Calculate appropriate zoom value for a particular boundingVolume\n * @param {BoundingSphere, OrientedBoundingBox} boundingVolume - the instance of bounding volume\n * @returns {number} - zoom value\n */\nexport function getZoomFromBoundingVolume(boundingVolume) {\n  const {halfAxes, radius, width, height} = boundingVolume;\n\n  if (halfAxes) {\n    // OrientedBoundingBox\n    const obbSize = getObbSize(halfAxes);\n    // Use WGS84_RADIUS_Z to allign with BoundingSphere algorithm\n    return Math.log2(WGS84_RADIUS_Z / obbSize);\n  } else if (radius) {\n    // BoundingSphere\n    return Math.log2(WGS84_RADIUS_Z / radius);\n  } else if (height && width) {\n    // BoundingRectangle\n    const zoomX = Math.log2(WGS84_RADIUS_X / width);\n    const zoomY = Math.log2(WGS84_RADIUS_Y / height);\n\n    return (zoomX + zoomY) / 2;\n  }\n\n  return 1;\n}\n\nfunction getObbSize(halfAxes) {\n  halfAxes.getColumn(0, scratchVector);\n  const axeY = halfAxes.getColumn(1);\n  const axeZ = halfAxes.getColumn(2);\n  const farthestVertex = scratchVector.add(axeY).add(axeZ);\n  const size = farthestVertex.len();\n  return size;\n}\n"]},"metadata":{},"sourceType":"module"}