{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/ESG-dell/Documents/Dev/Hachathon-miasta/PTA-frontend/node_modules/@babel/runtime/regenerator\";\nimport _awaitAsyncGenerator from \"C:/Users/ESG-dell/Documents/Dev/Hachathon-miasta/PTA-frontend/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator\";\nimport _wrapAsyncGenerator from \"C:/Users/ESG-dell/Documents/Dev/Hachathon-miasta/PTA-frontend/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator\";\n\nfunction _asyncIterator(iterable) { var method, async, sync, retry = 2; if (typeof Symbol !== \"undefined\") { async = Symbol.asyncIterator; sync = Symbol.iterator; } while (retry--) { if (async && (method = iterable[async]) != null) { return method.call(iterable); } if (sync && (method = iterable[sync]) != null) { return new AsyncFromSyncIterator(method.call(iterable)); } async = \"@@asyncIterator\"; sync = \"@@iterator\"; } throw new TypeError(\"Object is not async iterable\"); }\n\nfunction AsyncFromSyncIterator(s) { AsyncFromSyncIterator = function AsyncFromSyncIterator(s) { this.s = s; this.n = s.next; }; AsyncFromSyncIterator.prototype = { s: null, n: null, next: function next() { return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments)); }, return: function _return(value) { var ret = this.s.return; if (ret === undefined) { return Promise.resolve({ value: value, done: true }); } return AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments)); }, throw: function _throw(value) { var thr = this.s.return; if (thr === undefined) return Promise.reject(value); return AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments)); } }; function AsyncFromSyncIteratorContinuation(r) { if (Object(r) !== r) { return Promise.reject(new TypeError(r + \" is not an object.\")); } var done = r.done; return Promise.resolve(r.value).then(function (value) { return { value: value, done: done }; }); } return new AsyncFromSyncIterator(s); }\n\nimport { isBrowser, toArrayBuffer } from '@loaders.gl/loader-utils';\nexport function makeStreamIterator(stream, options) {\n  return isBrowser ? makeBrowserStreamIterator(stream, options) : makeNodeStreamIterator(stream, options);\n}\n\nfunction makeBrowserStreamIterator(_x, _x2) {\n  return _makeBrowserStreamIterator.apply(this, arguments);\n}\n\nfunction _makeBrowserStreamIterator() {\n  _makeBrowserStreamIterator = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(stream, options) {\n    var reader, nextBatchPromise, currentBatchPromise, _yield$_awaitAsyncGen, done, value;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            reader = stream.getReader();\n            _context.prev = 1;\n\n          case 2:\n            if (!true) {\n              _context.next = 16;\n              break;\n            }\n\n            currentBatchPromise = nextBatchPromise || reader.read();\n\n            if (options !== null && options !== void 0 && options._streamReadAhead) {\n              nextBatchPromise = reader.read();\n            }\n\n            _context.next = 7;\n            return _awaitAsyncGenerator(currentBatchPromise);\n\n          case 7:\n            _yield$_awaitAsyncGen = _context.sent;\n            done = _yield$_awaitAsyncGen.done;\n            value = _yield$_awaitAsyncGen.value;\n\n            if (!done) {\n              _context.next = 12;\n              break;\n            }\n\n            return _context.abrupt(\"return\");\n\n          case 12:\n            _context.next = 14;\n            return toArrayBuffer(value);\n\n          case 14:\n            _context.next = 2;\n            break;\n\n          case 16:\n            _context.next = 21;\n            break;\n\n          case 18:\n            _context.prev = 18;\n            _context.t0 = _context[\"catch\"](1);\n            reader.releaseLock();\n\n          case 21:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[1, 18]]);\n  }));\n  return _makeBrowserStreamIterator.apply(this, arguments);\n}\n\nfunction makeNodeStreamIterator(_x3, _x4) {\n  return _makeNodeStreamIterator.apply(this, arguments);\n}\n\nfunction _makeNodeStreamIterator() {\n  _makeNodeStreamIterator = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(stream, options) {\n    var _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, chunk;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _iteratorAbruptCompletion = false;\n            _didIteratorError = false;\n            _context2.prev = 2;\n            _iterator = _asyncIterator(stream);\n\n          case 4:\n            _context2.next = 6;\n            return _awaitAsyncGenerator(_iterator.next());\n\n          case 6:\n            if (!(_iteratorAbruptCompletion = !(_step = _context2.sent).done)) {\n              _context2.next = 13;\n              break;\n            }\n\n            chunk = _step.value;\n            _context2.next = 10;\n            return toArrayBuffer(chunk);\n\n          case 10:\n            _iteratorAbruptCompletion = false;\n            _context2.next = 4;\n            break;\n\n          case 13:\n            _context2.next = 19;\n            break;\n\n          case 15:\n            _context2.prev = 15;\n            _context2.t0 = _context2[\"catch\"](2);\n            _didIteratorError = true;\n            _iteratorError = _context2.t0;\n\n          case 19:\n            _context2.prev = 19;\n            _context2.prev = 20;\n\n            if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n              _context2.next = 24;\n              break;\n            }\n\n            _context2.next = 24;\n            return _awaitAsyncGenerator(_iterator.return());\n\n          case 24:\n            _context2.prev = 24;\n\n            if (!_didIteratorError) {\n              _context2.next = 27;\n              break;\n            }\n\n            throw _iteratorError;\n\n          case 27:\n            return _context2.finish(24);\n\n          case 28:\n            return _context2.finish(19);\n\n          case 29:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[2, 15, 19, 29], [20,, 24, 28]]);\n  }));\n  return _makeNodeStreamIterator.apply(this, arguments);\n}","map":{"version":3,"sources":["../../../../src/iterators/make-iterator/make-stream-iterator.ts"],"names":["isBrowser","makeBrowserStreamIterator","makeNodeStreamIterator","reader","stream","currentBatchPromise","nextBatchPromise","options","value","toArrayBuffer"],"mappings":";;;;;;;;AACA,SAAA,SAAA,EAAA,aAAA,QAAA,0BAAA;AAUA,OAAO,SAAA,kBAAA,CAAA,MAAA,EAAA,OAAA,EAGuB;AAC5B,SAAOA,SAAS,GACZC,yBAAyB,CAAA,MAAA,EADb,OACa,CADb,GAEZC,sBAAsB,CAAA,MAAA,EAF1B,OAE0B,CAF1B;AAGD;;SAOD,yB;;;;;0FAAA,iBAAA,MAAA,EAAA,OAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAaQC,YAAAA,MAbR,GAaiBC,MAAM,CAArB,SAAeA,EAbjB;AAAA;;AAAA;AAAA,iBAmBI,IAnBJ;AAAA;AAAA;AAAA;;AAoBYC,YAAAA,mBApBZ,GAoBkCC,gBAAgB,IAAIH,MAAM,CAAtD,IAAgDA,EApBtD;;AAuBM,gBAAII,OAAJ,KAAA,IAAIA,IAAAA,OAAJ,KAAA,KAAA,CAAIA,IAAAA,OAAO,CAAX,gBAAA,EAA+B;AAC7BD,cAAAA,gBAAgB,GAAGH,MAAM,CAAzBG,IAAmBH,EAAnBG;AACD;;AAzBP;AAAA,wCA4BM,mBA5BN;;AAAA;AAAA;AA4BY,YAAA,IA5BZ,yBA4BY,IA5BZ;AA4BmBE,YAAAA,KA5BnB,yBA4BmBA,KA5BnB;;AAAA,iBA8BM,IA9BN;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAkCM,mBAAMC,aAAa,CAAnB,KAAmB,CAAnB;;AAlCN;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAuCIN,YAAAA,MAAM,CAANA,WAAAA;;AAvCJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;SAgDA,sB;;;;;uFAAA,kBAAA,MAAA,EAAA,OAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uCAME,MANF;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAME,YAAA,KANF;AAAA;AAOI,mBAAMM,aAAa,CAAnB,KAAmB,CAAnB;;AAPJ;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G","sourcesContent":["import type {Readable} from 'stream';\nimport {isBrowser, toArrayBuffer} from '@loaders.gl/loader-utils';\n\nexport type StreamIteratorOptions = {\n  _streamReadAhead?: boolean;\n};\n\n/**\n * Returns an async iterable that reads from a stream (works in both Node.js and browsers)\n * @param stream stream to iterator over\n */\nexport function makeStreamIterator(\n  stream: ReadableStream | Readable,\n  options?: StreamIteratorOptions\n): AsyncIterable<ArrayBuffer> {\n  return isBrowser\n    ? makeBrowserStreamIterator(stream as ReadableStream, options)\n    : makeNodeStreamIterator(stream as Readable, options);\n}\n\n/**\n * Returns an async iterable that reads from a DOM (browser) stream\n * @param stream stream to iterate from\n * @see https://jakearchibald.com/2017/async-iterators-and-generators/#making-streams-iterate\n */\nasync function* makeBrowserStreamIterator(\n  stream: ReadableStream,\n  options?: StreamIteratorOptions\n): AsyncIterable<ArrayBuffer> {\n  // WhatWG: stream is supposed to have a `getIterator` method\n  // if (typeof stream.getIterator === 'function') {\n  //   return stream.getIterator();\n  // }\n  // if (typeof stream[Symbol.asyncIterator] === 'function') {\n  //   return makeToArrayBufferIterator(stream);\n  // }\n\n  // In the browser, we first need to get a lock on the stream\n  const reader = stream.getReader();\n\n  let nextBatchPromise: Promise<{done?: boolean; value?: Uint8Array}> | undefined;\n\n  try {\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      const currentBatchPromise = nextBatchPromise || reader.read();\n      // Issue a read for an additional batch, while we await the next batch\n      // Idea is to make fetching happen in parallel with processing / parsing\n      if (options?._streamReadAhead) {\n        nextBatchPromise = reader.read();\n      }\n      // Read from the stream\n      // value is a Uint8Array\n      const {done, value} = await currentBatchPromise;\n      // Exit if we're done\n      if (done) {\n        return;\n      }\n      // Else yield the chunk\n      yield toArrayBuffer(value);\n    }\n  } catch (error) {\n    // TODO - examples makes it look like this should always be called,\n    // but that generates exceptions so only call it if we do not reach the end\n    reader.releaseLock();\n  }\n}\n\n/**\n * Returns an async iterable that reads from a DOM (browser) stream\n * @param stream stream to iterate from\n * @note Requires Node.js >= 10\n */\nasync function* makeNodeStreamIterator(\n  stream: Readable,\n  options?: StreamIteratorOptions\n): AsyncIterable<ArrayBuffer> {\n  // Hacky test for node version to ensure we don't call bad polyfills\n  // NODE 10+: stream is an asyncIterator\n  for await (const chunk of stream) {\n    yield toArrayBuffer(chunk); // Coerce each chunk to ArrayBuffer\n  }\n}\n/* TODO - remove NODE < 10\n * @see https://github.com/bustle/streaming-iterables, MIT license\n *\n  if (typeof stream[Symbol.asyncIterator] === 'function') {\n    return;\n  }\n\n  // TODO - check if is this ever used in Node 10+?\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const data = stream.read();\n    if (data !== null) {\n      yield toArrayBuffer(data);\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n    if (stream._readableState?.ended) {\n      return;\n    }\n    await onceReadable(stream);\n  }\n\nasync function onceReadable(stream: Readable): Promise<any> {\n  return new Promise((resolve) => {\n    stream.once('readable', resolve);\n  });\n}\n  */\n"]},"metadata":{},"sourceType":"module"}